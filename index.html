<!DOCTYPE html>
<html lang="en">
<!--
    WikiPath - Wikipedia Navigation Game
    Version: 3.9.6
    Last Updated: 2024-12-02
    
    Changelog:
    - v3.9.6: Fixed "URI malformed" error with try-catch on decodeURIComponent
    - v3.9.5: Added extensive debugging + safety check for hint bug (suggesting current page)
    - v3.9.4: Fixed hint highlighting selector (#game-area not #content) + added debugging
    - v3.9.3: Fixed hint keyboard shortcut and gold highlight (now working!)
    - v3.9.2: Added 'H' keyboard shortcut for hints + visual gold highlight of suggested link
    - v3.9.1: Removed non-clickable links from page (cleaner UX)
    - v3.9.0: Added minimum clicks solver, hints, and optimal path comparison
    - v3.8.4: Fixed redirect bug - now detects win when clicking redirect links
    [previous changelog entries...]
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiPath - Connect the Pages</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
        }

        /* Compact Header */
        .game-header {
            background: white;
            color: #202122;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            border-bottom: 3px solid #0645ad;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
        }

        /* Left Side - Branding & Stats */
        .header-left {
            display: flex;
            align-items: center;
            gap: 25px;
        }

        .game-branding {
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
        }

        .game-branding h1 {
            font-size: 1.4em;
            color: #0645ad;
            font-weight: 600;
        }

        .game-branding .logo {
            font-size: 1.8em;
        }

        .header-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-item-compact {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .stat-label-compact {
            font-size: 0.65em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-value-compact {
            font-size: 1em;
            font-weight: 700;
            color: #0645ad;
        }

        /* NEW: Minimum clicks styling */
        .stat-value-compact.minimum {
            color: #28a745;
        }

        .stat-value-compact.loading {
            color: #999;
            font-size: 0.8em;
        }

        /* Center - Target Page (Prominent) */
        .header-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .target-display {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 2px solid #0645ad;
            border-radius: 12px;
            padding: 12px 24px;
            text-align: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(6, 69, 173, 0.15);
        }

        .target-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(6, 69, 173, 0.25);
            border-color: #0b0080;
        }

        .target-label {
            font-size: 0.7em;
            color: #0645ad;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #target-page-display {
            font-size: 1.3em;
            line-height: 1.3;
            color: #0b0080;
            font-weight: 700;
        }

        /* Right Side - Mode Switch */
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Compact Mode Switch */
        .mode-switch-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .mode-switch-label {
            font-size: 0.65em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .mode-switch {
            display: flex;
            background: #e0e0e0;
            border-radius: 20px;
            padding: 3px;
            gap: 3px;
            position: relative;
        }

        .mode-switch-btn {
            background: transparent;
            border: none;
            color: #666;
            padding: 6px 14px;
            border-radius: 17px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .mode-switch-btn:hover {
            color: #333;
        }

        .mode-switch-btn.active {
            background: white;
            color: #0645ad;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Old Mode Toggle - Remove */
        .mode-toggle {
            display: none;
        }

        /* Old Stats Bar - Remove */
        .stats-bar {
            display: none;
        }

        .stat-item {
            display: none;
        }

        .stat-item.target {
            display: none;
        }

        /* Difficulty Badge */
        .difficulty-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.65em;
            font-weight: 700;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .difficulty-easy {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1.5px solid #4caf50;
        }

        .difficulty-medium {
            background: #fff3e0;
            color: #e65100;
            border: 1.5px solid #ff9800;
        }

        .difficulty-hard {
            background: #ffebee;
            color: #c62828;
            border: 1.5px solid #f44336;
        }

        .difficulty-expert {
            background: #f3e5f5;
            color: #6a1b9a;
            border: 1.5px solid #9c27b0;
        }

        /* Target Tooltip */
        .target-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px;
            background: white;
            color: #333;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 300px;
            max-width: 400px;
            text-align: left;
        }

        .target-display:hover .target-tooltip {
            display: block;
        }

        .target-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid white;
        }

        .target-tooltip h4 {
            margin-bottom: 8px;
            color: #0645ad;
            font-size: 1em;
        }

        .target-tooltip p {
            font-size: 0.9em;
            line-height: 1.5;
            color: #555;
        }

        /* Settings Menu */
        .settings-menu {
            position: relative;
        }

        .settings-btn {
            background: #f0f0f0;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: #e0e0e0;
        }

        /* Collapsible Path Panel */
        .path-panel {
            position: fixed;
            right: -350px;
            top: 0;
            width: 350px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            z-index: 200;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .path-panel.open {
            right: 0;
        }

        .path-panel-header {
            background: #0645ad;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .path-panel-header h3 {
            font-size: 1.1em;
        }

        .path-panel-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .path-panel-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .path-panel-content {
            padding: 20px;
        }

        .path-timeline {
            position: relative;
            padding-left: 30px;
        }

        .path-timeline::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #e0e0e0;
        }

        .path-timeline-item {
            position: relative;
            margin-bottom: 20px;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #0645ad;
        }

        .path-timeline-item.current {
            background: #e3f2fd;
            border-left-color: #1976d2;
            border-left-width: 4px;
        }

        .path-timeline-item::before {
            content: '';
            position: absolute;
            left: -34px;
            top: 15px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #0645ad;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #e0e0e0;
        }

        .path-timeline-item.current::before {
            background: #1976d2;
            width: 16px;
            height: 16px;
            left: -36px;
            top: 13px;
        }

        .path-item-number {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .path-item-title {
            font-size: 0.95em;
            color: #202122;
            font-weight: 500;
        }

        /* Floating Action Menu */
        .fab-menu {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 150;
        }

        .fab-menu-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #0645ad;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(6, 69, 173, 0.4);
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .fab-menu-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(6, 69, 173, 0.5);
        }

        .fab-menu-button.active {
            background: #0b0080;
        }

        .fab-menu-items {
            position: absolute;
            bottom: 75px;
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            padding: 8px;
            min-width: 200px;
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 151;
        }

        .fab-menu.open .fab-menu-items {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .fab-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            cursor: pointer;
            border-radius: 8px;
            font-size: 0.95em;
            color: #333;
            transition: background 0.2s;
            font-weight: 500;
            user-select: none;
            position: relative;
        }

        .fab-menu-item .keyboard-shortcut {
            margin-left: auto;
            font-size: 0.75em;
            padding: 2px 6px;
            background: #e0e0e0;
            border-radius: 3px;
            color: #666;
            font-family: monospace;
            font-weight: 600;
        }

        .fab-menu-item:hover {
            background: #f0f0f0;
        }

        .fab-menu-item.danger:hover {
            background: #ffebee;
            color: #c62828;
        }

        .fab-menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .fab-menu-item .emoji {
            font-size: 1.3em;
            width: 24px;
            text-align: center;
        }

        .fab-menu-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }

        /* Container with TOC */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            min-height: calc(100vh - 80px);
            display: flex;
            position: relative;
        }

        /* Table of Contents (KEPT) */
        .toc-container {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            position: sticky;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .toc-title {
            font-weight: 700;
            font-size: 1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0645ad;
            color: #202122;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toc-collapse-controls {
            display: flex;
            gap: 5px;
        }

        .toc-collapse-btn {
            background: transparent;
            border: 1px solid #0645ad;
            color: #0645ad;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 700;
            line-height: 1;
            min-width: 28px;
        }

        .toc-collapse-btn:hover {
            background: #0645ad;
            color: white;
        }

        .toc-list {
            list-style: none;
        }

        .toc-item {
            margin-bottom: 4px;
        }

        .toc-section-header {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 5px 0;
            font-weight: 600;
            color: #202122;
            font-size: 0.9em;
        }

        .toc-section-header:hover {
            color: #0645ad;
        }

        .toc-collapse-icon {
            font-size: 0.7em;
            transition: transform 0.2s;
        }

        .toc-section-header.collapsed .toc-collapse-icon {
            transform: rotate(-90deg);
        }

        .toc-section-header.no-children {
            cursor: pointer;
            padding-left: 0;
        }

        .toc-subsections {
            list-style: none;
            margin-left: 15px;
            margin-top: 4px;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .toc-subsections.collapsed {
            max-height: 0;
        }

        .toc-link {
            color: #0645ad;
            text-decoration: none;
            font-size: 0.9em;
            display: block;
            padding: 5px 0;
            cursor: pointer;
            line-height: 1.4;
            transition: color 0.2s;
        }

        .toc-link:hover {
            color: #0b0080;
            text-decoration: underline;
        }

        .toc-link.active {
            font-weight: 700;
            color: #0b0080;
        }

        /* Main content area */
        .content-area {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }

        .wikipedia-article {
            font-family: 'Linux Libertine', Georgia, Times, serif;
            font-size: 14px;
            line-height: 1.6;
            color: #202122;
            max-width: 900px;
        }

        .wikipedia-article h1 {
            font-size: 3em;
            margin-bottom: 0.3em;
            margin-top: 0.2em;
            padding-bottom: 0.2em;
            border-bottom: 1px solid #a2a9b1;
            font-family: 'Linux Libertine', Georgia, Times, serif;
            font-weight: 400;
            line-height: 1.2;
            color: #202122;
        }

        .wikipedia-article h2 {
            font-size: 1.5em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            padding-bottom: 0.2em;
            border-bottom: 1px solid #a2a9b1;
        }

        .wikipedia-article h3 {
            font-size: 1.2em;
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .wikipedia-article p {
            margin-bottom: 0.8em;
        }

        .wikipedia-article a {
            color: #0645ad;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            border-bottom: 1px solid transparent;
            position: relative;
        }

        .wikipedia-article a:hover {
            color: #0b0080;
            border-bottom: 1px solid #0645ad;
            background: rgba(6, 69, 173, 0.05);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
        }

        .wikipedia-article a.visited-link {
            color: #7c3aed;
            opacity: 0.85;
        }

        .wikipedia-article a.visited-link:hover {
            color: #6d28d9;
            border-bottom-color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }

        .wikipedia-article a.disambiguation-link {
            color: #dc2626;
            font-style: italic;
            font-weight: 600;
        }

        .wikipedia-article a.disambiguation-link:hover {
            color: #991b1b;
            border-bottom-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
        }

        /* Link Preview Tooltip */
        .link-preview {
            display: none;
            position: fixed;
            background: white;
            border: 2px solid #0645ad;
            border-radius: 8px;
            padding: 12px 16px;
            max-width: 350px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 10000;
            pointer-events: none;
        }

        .link-preview.active {
            display: block;
        }

        .link-preview-title {
            font-weight: 700;
            color: #0645ad;
            margin-bottom: 6px;
            font-size: 1.05em;
        }

        .link-preview-text {
            color: #333;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .link-preview-loading {
            color: #666;
            font-style: italic;
            font-size: 0.85em;
        }

        .wikipedia-article ul, .wikipedia-article ol {
            margin-left: 1.6em;
            margin-bottom: 0.8em;
        }

        .wikipedia-article img {
            max-width: 100%;
            height: auto;
        }

        /* Infobox positioning - float to the right like Wikipedia */
        .wikipedia-article .infobox {
            float: right;
            clear: right;
            width: 300px;
            margin: 0 0 1em 1em;
            padding: 0.5em;
            background: #f8f9fa;
            border: 1px solid #a2a9b1;
            font-size: 0.9em;
        }

        .wikipedia-article .infobox-image {
            text-align: center;
            margin-bottom: 0.5em;
        }

        .wikipedia-article .infobox img {
            width: 100%;
            height: auto;
        }

        .wikipedia-article .infobox th,
        .wikipedia-article .infobox td {
            padding: 0.3em 0.5em;
            vertical-align: top;
        }

        .wikipedia-article .infobox th {
            text-align: left;
            font-weight: 600;
            background: #eaecf0;
        }

        .wikipedia-article .infobox caption {
            font-weight: bold;
            font-size: 1.1em;
            padding: 0.5em;
            background: #eaecf0;
        }

        /* Make sure content flows around infobox */
        .wikipedia-article p {
            margin-bottom: 0.8em;
            clear: none;
        }

        /* Hide full disclaimer boxes, show compact version */
        .wikipedia-article .ambox,
        .wikipedia-article .hatnote,
        .wikipedia-article .dablink {
            display: none !important;
        }

        /* Hide edit buttons */
        .wikipedia-article .mw-editsection,
        .wikipedia-article [class*="editsection"] {
            display: none !important;
        }

        /* Starting Page Indicator */
        .starting-page-indicator {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }

        .starting-page-indicator .icon {
            font-size: 1.5em;
        }

        .starting-page-indicator .text {
            flex: 1;
        }

        .starting-page-indicator .label {
            font-weight: 700;
            color: #2e7d32;
            font-size: 0.9em;
            margin-bottom: 2px;
        }

        .starting-page-indicator .description {
            font-size: 0.85em;
            color: #1b5e20;
        }

        /* Article Notice Icons - Top Right Corner */
        .article-notices-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            z-index: 10;
        }

        .article-notice {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 5px 7px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: help;
            position: relative;
            min-width: 28px;
            height: 28px;
        }

        .article-notice.verification {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }

        .article-notice.cleanup {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .article-notice.recent-changes {
            background: #e3f2fd;
            color: #0d47a1;
            border: 1px solid #2196f3;
        }

        .article-notice.recent-death {
            background: #f3e5f5;
            color: #4a148c;
            border: 1px solid #9c27b0;
        }

        .article-notice:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            padding: 8px 12px;
            background: #333;
            color: white;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Make article title area have relative positioning for notices */
        .wikipedia-article {
            position: relative;
        }

        /* ======================
           DEBUG MODE (LITE)
           ====================== */
        
        .debug-toggle {
            display: none; /* Hidden by default - controlled by JS */
            background: #ff9800;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: background 0.2s;
        }

        .debug-toggle:hover {
            background: #f57c00;
        }

        .debug-toggle.active {
            background: #4caf50;
        }

        .debug-panel {
            display: none;
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
        }

        .debug-panel.active {
            display: block;
        }

        .debug-panel h3 {
            margin: 0 0 15px 0;
            color: #e65100;
            font-size: 1.1em;
        }

        .debug-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .debug-section:last-child {
            margin-bottom: 0;
        }

        .debug-section h4 {
            margin: 0 0 10px 0;
            color: #f57c00;
            font-size: 0.95em;
        }

        .debug-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .debug-input:focus {
            outline: none;
            border-color: #ff9800;
        }

        .debug-button {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            margin-right: 8px;
            transition: background 0.2s;
        }

        .debug-button:hover {
            background: #f57c00;
        }

        .debug-button.secondary {
            background: #757575;
        }

        .debug-button.secondary:hover {
            background: #616161;
        }

        .debug-error {
            color: #d32f2f;
            font-size: 0.85em;
            margin-top: 5px;
            display: none;
        }

        .debug-error.active {
            display: block;
        }

        .debug-autocomplete {
            position: absolute;
            background: white;
            border: 2px solid #ff9800;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .debug-autocomplete.active {
            display: block;
        }

        .debug-autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.9em;
        }

        .debug-autocomplete-item:last-child {
            border-bottom: none;
        }

        .debug-autocomplete-item:hover {
            background: #fff3e0;
        }

        .debug-autocomplete-item.selected {
            background: #ffe0b2;
        }

        .debug-input-wrapper {
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 60px 40px;
            font-size: 1.1em;
            color: #666;
        }

        .loading::before {
            content: '';
            display: block;
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0645ad;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Page Transition Animation */
        .wikipedia-article {
            animation: fadeIn 0.4s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Click Animation Feedback */
        @keyframes clickPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.95);
            }
            100% {
                transform: scale(1);
            }
        }

        .click-feedback {
            animation: clickPulse 0.2s ease;
        }

        /* Confetti Animation */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #0645ad;
            position: absolute;
            animation: confettiFall 3s linear forwards;
            z-index: 9999;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* Success celebration animation */
        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        .celebrating {
            animation: celebrate 0.5s ease-in-out;
        }

        /* Ripple effect for button clicks */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            animation: rippleEffect 0.6s ease-out;
        }

        @keyframes rippleEffect {
            to {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        .error {
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #c62828;
        }

        /* Win Modal - Improved */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        /* Statistics Modal */
        .stats-modal .modal-content {
            max-width: 700px;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .stats-header h2 {
            margin: 0;
        }

        .reset-stats-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: background 0.2s;
        }

        .reset-stats-btn:hover {
            background: #d32f2f;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card.highlight {
            border-color: #0645ad;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
        }

        .stat-card-value {
            font-size: 2em;
            font-weight: 700;
            color: #0645ad;
            margin-bottom: 5px;
        }

        .stat-card-label {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-card-sublabel {
            font-size: 0.75em;
            color: #999;
            margin-top: 3px;
        }

        .recent-games-section {
            margin-top: 25px;
        }

        .recent-games-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        .recent-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid #0645ad;
        }

        .recent-game-item.gave-up {
            border-left-color: #f44336;
            opacity: 0.7;
        }

        .recent-game-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .recent-game-result {
            font-weight: 600;
            color: #0645ad;
        }

        .recent-game-result.gave-up {
            color: #f44336;
        }

        .recent-game-stats {
            display: flex;
            gap: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .recent-game-date {
            font-size: 0.8em;
            color: #999;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 650px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalSlideIn {
            from {
                transform: scale(0.8) translateY(-50px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            color: #0645ad;
            font-size: 2.2em;
            margin-bottom: 25px;
            text-align: center;
        }

        .win-stats {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #e0e0e0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #555;
            font-size: 1em;
        }

        .stat-value {
            color: #0645ad;
            font-weight: 700;
            font-size: 1.2em;
        }

        .win-path {
            margin: 25px 0;
        }

        .win-path h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }

        .path-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #0645ad;
            transition: all 0.2s;
        }

        .path-item:hover {
            background: #e3f2fd;
            transform: translateX(5px);
        }

        .path-item-number {
            background: #0645ad;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85em;
            font-weight: 700;
            flex-shrink: 0;
        }

        /* NEW: Optimal path styling */
        .path-item.optimal {
            border-left-color: #28a745;
            background: #e8f5e9;
        }

        .path-item.optimal .path-item-number {
            background: #28a745;
        }

        .performance-rating {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 25px;
            border: 3px solid;
        }

        .rating-perfect {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: white;
            border-color: #FF8C00;
        }

        .rating-excellent {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .rating-good {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0d47a1;
        }

        .rating-completed {
            background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
            color: white;
            border-color: #4a148c;
        }

        /* NEW: Path comparison styling */
        .path-comparison {
            margin: 25px 0;
        }

        .path-comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .efficiency-badge {
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 700;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
        }

        .modal-btn {
            flex: 1;
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.2s ease;
        }

        .modal-btn.primary {
            background: #0645ad;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #0b0080;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(6, 69, 173, 0.3);
        }

        .modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .modal-btn.secondary:hover {
            background: #e0e0e0;
        }

        .share-notification {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 2000;
            font-weight: 600;
        }

        .share-notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Search Overlay */
        .search-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            justify-content: center;
            align-items: flex-start;
            padding-top: 100px;
        }

        .search-overlay.active {
            display: flex;
        }

        .search-box {
            background: white;
            border-radius: 12px;
            padding: 25px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1em;
            border: 2px solid #0645ad;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: #0b0080;
        }

        .search-results {
            margin-top: 20px;
            max-height: 450px;
            overflow-y: auto;
        }

        .search-result-item {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 6px;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-item strong {
            color: #0645ad;
            font-weight: 700;
        }

        .search-hint {
            text-align: center;
            color: #999;
            font-size: 0.9em;
            margin-top: 15px;
        }

        /* Hint System */
        .hint-badge {
            position: fixed;
            bottom: 90px;
            left: 20px;
            background: white;
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 12px 18px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 140;
            display: none;
            animation: slideInLeft 0.3s ease;
        }

        .hint-badge.active {
            display: block;
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hint-badge.warmer {
            border-color: #f59e0b;
            background: #fffbeb;
        }

        .hint-badge.colder {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .hint-badge.hot {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .hint-text {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }

        .hint-icon {
            font-size: 1.2em;
            margin-right: 6px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .header-top {
                flex-wrap: wrap;
                gap: 10px;
            }

            .header-left {
                flex: 1 1 100%;
                justify-content: space-between;
            }

            .header-center {
                flex: 1 1 100%;
                order: 3;
            }

            .header-right {
                order: 2;
            }

            .target-display {
                width: 100%;
            }

            .container {
                flex-direction: column;
            }

            .toc-container {
                width: 100%;
                height: auto;
                max-height: 200px;
                position: relative;
                top: 0;
            }

            .content-area {
                padding: 20px;
            }

            .path-panel {
                width: 100%;
                right: -100%;
            }

            .fab-menu {
                bottom: 15px;
                right: 15px;
            }

            .fab-menu-button {
                width: 55px;
                height: 55px;
            }

            .modal-content {
                padding: 25px;
                margin: 20px;
                max-width: 95%;
            }

            .modal-buttons {
                flex-direction: column;
            }
        }

        @media (max-width: 480px) {
            .game-branding h1 {
                font-size: 1.1em;
            }

            .header-stats {
                gap: 12px;
            }

            .stat-value-compact {
                font-size: 0.9em;
            }

            #target-page-display {
                font-size: 1.1em;
            }
        }

        /* Hint highlight animation */
        .hint-highlight {
            background-color: gold !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            animation: hint-pulse 1s ease-in-out infinite;
            font-weight: 600 !important;
            color: #000 !important;
        }

        @keyframes hint-pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
        }
    </style>
</head>
<body>
    <div class="game-header" id="game-header">
        <div class="header-top">
            <!-- Left: Branding & Stats -->
            <div class="header-left">
                <div class="game-branding">
                    <span class="logo">üåê</span>
                    <h1>WikiPath <span style="font-size: 0.5em; color: #666; font-weight: 400;">v3.9.6</span></h1>
                </div>
                <div class="header-stats">
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Clicks</div>
                        <div class="stat-value-compact" id="click-counter">0</div>
                    </div>
                    <!-- NEW: Minimum clicks display -->
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Minimum</div>
                        <div class="stat-value-compact minimum" id="min-clicks-display">-</div>
                    </div>
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Time</div>
                        <div class="stat-value-compact" id="timer">0:00</div>
                    </div>
                </div>
            </div>

            <!-- Center: Target Page (Prominent) -->
            <div class="header-center">
                <div class="target-display">
                    <div class="target-label">
                        <span>üéØ</span>
                        <span>TARGET</span>
                    </div>
                    <div>
                        <span id="target-page-display">Loading...</span>
                        <span class="difficulty-badge" id="difficulty-badge"></span>
                    </div>
                    <div class="target-tooltip" id="target-tooltip">
                        <h4 id="tooltip-title"></h4>
                        <p id="tooltip-description"></p>
                    </div>
                </div>
            </div>

            <!-- Right: Mode Switch -->
            <div class="header-right">
                <button class="debug-toggle" id="debug-toggle" onclick="toggleDebugMode()">
                    üêõ Debug
                </button>
                <div class="mode-switch-container">
                    <div class="mode-switch-label">Mode</div>
                    <div class="mode-switch">
                        <button class="mode-switch-btn" id="explore-mode-btn" onclick="switchToExploreMode()">
                            Explore
                        </button>
                        <button class="mode-switch-btn active" id="daily-mode-btn" onclick="switchToDailyMode()">
                            Daily
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <h3>üêõ Debug Mode</h3>
        
        <div class="debug-section">
            <h4>üéÆ Custom Game Setup</h4>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-start-page" placeholder="Start Page (e.g., Albert Einstein)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-start"></div>
            </div>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-target-page" placeholder="Target Page (e.g., Physics)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-target"></div>
            </div>
            <div class="debug-error" id="debug-game-error"></div>
            <button class="debug-button" onclick="startDebugGame()">Start Custom Game</button>
            <button class="debug-button secondary" onclick="fillRandomPages()">Fill Random</button>
        </div>

        <div class="debug-section">
            <h4>üîç Page Preview</h4>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-preview-page" placeholder="Page Name (e.g., Mainframe)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-preview"></div>
            </div>
            <div class="debug-error" id="debug-preview-error"></div>
            <button class="debug-button" onclick="loadDebugPreview()">Load Preview</button>
            <button class="debug-button secondary" onclick="fillRandomPreview()">Fill Random</button>
        </div>
    </div>

    <!-- Path Panel (Collapsible) -->
    <div class="path-panel" id="path-panel">
        <div class="path-panel-header">
            <h3>üó∫Ô∏è Your Journey</h3>
            <button class="path-panel-close" onclick="togglePathPanel()">√ó</button>
        </div>
        <div class="path-panel-content">
            <div class="path-timeline" id="path-timeline"></div>
        </div>
    </div>

    <!-- Floating Action Menu -->
    <div class="fab-menu" id="fab-menu">
        <button class="fab-menu-button" onclick="toggleFabMenu()">
            ‚ö°
        </button>
        <div class="fab-menu-items">
            <button class="fab-menu-item" onclick="togglePathPanel(); closeFabMenu();">
                <span class="emoji">üó∫Ô∏è</span>
                <span>View Path</span>
            </button>
            <!-- NEW: Hint button now functional -->
            <button class="fab-menu-item" id="hint-btn" onclick="showSolverHint(); closeFabMenu();" title="Get Hint (H)">
                <span class="emoji">üí°</span>
                <span>Get Hint</span>
            </button>
            <button class="fab-menu-item" onclick="openSearch(); closeFabMenu();">
                <span class="emoji">üîç</span>
                <span>Search (Ctrl+F)</span>
            </button>
            <button class="fab-menu-item" onclick="openStats(); closeFabMenu();">
                <span class="emoji">üìä</span>
                <span>Statistics</span>
            </button>
            <div class="fab-menu-divider"></div>
            <button class="fab-menu-item danger" onclick="giveUp(); closeFabMenu();">
                <span class="emoji">üè≥Ô∏è</span>
                <span>Give Up</span>
            </button>
            <button class="fab-menu-item" id="new-game-btn" onclick="handleNewGame(); closeFabMenu();">
                <span class="emoji">üéÆ</span>
                <span>New Game</span>
                <span class="keyboard-shortcut">N</span>
            </button>
        </div>
    </div>

    <div class="container">
        <div class="toc-container" id="toc-container">
            <div class="toc-title">
                <span>Contents</span>
                <div class="toc-collapse-controls">
                    <button class="toc-collapse-btn" onclick="expandAllTOC()" title="Expand All">+</button>
                    <button class="toc-collapse-btn" onclick="collapseAllTOC()" title="Collapse All">‚àí</button>
                </div>
            </div>
            <ul class="toc-list" id="toc-list"></ul>
        </div>
        <div class="content-area" id="game-area">
            <div class="loading">Loading Wikipedia article...</div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal-overlay" id="win-modal">
        <div class="modal-content">
            <h2>üéâ Congratulations! üéâ</h2>
            <div class="win-stats">
                <div class="stat-row">
                    <span class="stat-label">Total Clicks:</span>
                    <span class="stat-value" id="final-clicks">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time Taken:</span>
                    <span class="stat-value" id="final-time">0:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Pages Visited:</span>
                    <span class="stat-value" id="final-pages">0</span>
                </div>
            </div>
            <div class="win-path" id="win-path"></div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="retryGame()">üîÑ Retry</button>
                <button class="modal-btn primary" onclick="shareResult()">üì§ Share</button>
                <button class="modal-btn secondary" onclick="startNewGame()">üéÆ New Game</button>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div class="modal-overlay stats-modal" id="stats-modal">
        <div class="modal-content">
            <div class="stats-header">
                <h2>üìä Your Statistics</h2>
                <button class="reset-stats-btn" onclick="stats.reset()">Reset Stats</button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-streak">0</div>
                    <div class="stat-card-label">Daily Streak</div>
                    <div class="stat-card-sublabel">üî• days in a row</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-games">0</div>
                    <div class="stat-card-label">Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-wins">0</div>
                    <div class="stat-card-label">Wins</div>
                    <div class="stat-card-sublabel" id="stat-winrate">0% win rate</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-best-clicks">-</div>
                    <div class="stat-card-label">Best Clicks</div>
                    <div class="stat-card-sublabel">üèÜ personal record</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-best-time">-</div>
                    <div class="stat-card-label">Best Time</div>
                    <div class="stat-card-sublabel">‚ö° fastest win</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-avg-clicks">-</div>
                    <div class="stat-card-label">Avg Clicks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-avg-time">-</div>
                    <div class="stat-card-label">Avg Time</div>
                </div>
            </div>

            <div class="recent-games-section">
                <h3>üìú Recent Games</h3>
                <div id="recent-games-list"></div>
            </div>

            <div class="modal-buttons" style="margin-top: 25px;">
                <button class="modal-btn secondary" onclick="closeStats()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Notification -->
    <div class="share-notification" id="share-notification">
        ‚úì Copied to clipboard!
    </div>

    <!-- Search Overlay (Ctrl+F) -->
    <div class="search-overlay" id="search-overlay">
        <div class="search-box">
            <input type="text" class="search-input" id="search-input" placeholder="Search within current article...">
            <div class="search-results" id="search-results"></div>
            <div class="search-hint">Press Ctrl+F to search ‚Ä¢ ESC to close</div>
        </div>
    </div>

    <!-- Link Preview Tooltip -->
    <div class="link-preview" id="link-preview">
        <div class="link-preview-title" id="preview-title"></div>
        <div class="link-preview-text" id="preview-text"></div>
    </div>

    <!-- Hint Badge -->
    <div class="hint-badge" id="hint-badge">
        <span class="hint-icon" id="hint-icon">üî•</span>
        <span class="hint-text" id="hint-text">Getting warmer!</span>
    </div>

    <script>
        // ======================
        // WIKIPEDIA PATH SOLVER
        // ======================

        class WikipathSolverBrowser {
            constructor() {
                this.cache = new Map();
                this.apiDelay = 150;
            }

            async getOutgoingLinks(pageTitle) {
                const cacheKey = `out:${pageTitle}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const url = `https://en.wikipedia.org/w/api.php?` +
                        `action=query&titles=${encodeURIComponent(pageTitle)}` +
                        `&prop=links&pllimit=max&format=json&origin=*&plnamespace=0`;

                    const response = await fetch(url);
                    const data = await response.json();

                    const pages = data.query?.pages || {};
                    const pageId = Object.keys(pages)[0];

                    if (pageId === '-1') return [];

                    const links = pages[pageId]?.links || [];
                    // FILTER OUT non-clickable links (same as game UI does)
                    // Only include links that don't contain ':' (filters out Wikipedia:, File:, Category:, etc.)
                    const linkTitles = links
                        .map(link => link.title)
                        .filter(title => !title.includes(':'));

                    this.cache.set(cacheKey, linkTitles);
                    await this.delay(this.apiDelay);

                    return linkTitles;
                } catch (error) {
                    console.error(`Error fetching links:`, error);
                    return [];
                }
            }

            async getIncomingLinks(pageTitle) {
                const cacheKey = `in:${pageTitle}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const url = `https://en.wikipedia.org/w/api.php?` +
                        `action=query&titles=${encodeURIComponent(pageTitle)}` +
                        `&prop=linkshere&lhlimit=max&format=json&origin=*&lhnamespace=0`;

                    const response = await fetch(url);
                    const data = await response.json();

                    const pages = data.query?.pages || {};
                    const pageId = Object.keys(pages)[0];

                    if (pageId === '-1') return [];

                    const linkshere = pages[pageId]?.linkshere || [];
                    // FILTER OUT non-clickable links (same as game UI does)
                    // Only include links that don't contain ':' (filters out Wikipedia:, File:, Category:, etc.)
                    const linkTitles = linkshere
                        .map(link => link.title)
                        .filter(title => !title.includes(':'));

                    this.cache.set(cacheKey, linkTitles);
                    await this.delay(this.apiDelay);

                    return linkTitles;
                } catch (error) {
                    console.error(`Error fetching incoming links:`, error);
                    return [];
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            normalizeTitle(title) {
                title = title.trim().replace(/_/g, ' ');
                return title.charAt(0).toUpperCase() + title.slice(1);
            }

            async findShortestPath(startPage, targetPage, maxDepth = 5) {
                console.log(`Finding path from "${startPage}" to "${targetPage}"...`);
                
                startPage = this.normalizeTitle(startPage);
                targetPage = this.normalizeTitle(targetPage);

                if (startPage === targetPage) {
                    return { found: true, path: [startPage], length: 0, pagesExplored: 0 };
                }

                const forwardQueue = [[startPage]];
                const forwardVisited = new Map([[startPage, [startPage]]]);
                const backwardQueue = [[targetPage]];
                const backwardVisited = new Map([[targetPage, [targetPage]]]);

                let depth = 0;
                let pagesExplored = 0;

                while (forwardQueue.length > 0 || backwardQueue.length > 0) {
                    if (depth > maxDepth) {
                        return {
                            found: false,
                            path: null,
                            length: null,
                            pagesExplored,
                            message: `No path found within ${maxDepth} degrees`
                        };
                    }

                    // Forward search
                    if (forwardQueue.length > 0) {
                        const forwardSize = forwardQueue.length;
                        for (let i = 0; i < forwardSize; i++) {
                            const currentPath = forwardQueue.shift();
                            const currentPage = currentPath[currentPath.length - 1];

                            if (backwardVisited.has(currentPage)) {
                                const backwardPath = backwardVisited.get(currentPage);
                                const completePath = [...currentPath, ...backwardPath.slice(1).reverse()];
                                return {
                                    found: true,
                                    path: completePath,
                                    length: completePath.length - 1,
                                    pagesExplored
                                };
                            }

                            const links = await this.getOutgoingLinks(currentPage);
                            pagesExplored++;

                            for (const link of links) {
                                if (!forwardVisited.has(link)) {
                                    const newPath = [...currentPath, link];
                                    forwardVisited.set(link, newPath);
                                    forwardQueue.push(newPath);

                                    if (backwardVisited.has(link)) {
                                        const backwardPath = backwardVisited.get(link);
                                        const completePath = [...newPath, ...backwardPath.slice(1).reverse()];
                                        return {
                                            found: true,
                                            path: completePath,
                                            length: completePath.length - 1,
                                            pagesExplored
                                        };
                                    }
                                }
                            }
                        }
                    }

                    // Backward search
                    if (backwardQueue.length > 0) {
                        const backwardSize = backwardQueue.length;
                        for (let i = 0; i < backwardSize; i++) {
                            const currentPath = backwardQueue.shift();
                            const currentPage = currentPath[currentPath.length - 1];

                            if (forwardVisited.has(currentPage)) {
                                const forwardPath = forwardVisited.get(currentPage);
                                const completePath = [...forwardPath, ...currentPath.slice(1).reverse()];
                                return {
                                    found: true,
                                    path: completePath,
                                    length: completePath.length - 1,
                                    pagesExplored
                                };
                            }

                            const links = await this.getIncomingLinks(currentPage);
                            pagesExplored++;

                            for (const link of links) {
                                if (!backwardVisited.has(link)) {
                                    const newPath = [...currentPath, link];
                                    backwardVisited.set(link, newPath);
                                    backwardQueue.push(newPath);

                                    if (forwardVisited.has(link)) {
                                        const forwardPath = forwardVisited.get(link);
                                        const completePath = [...forwardPath, ...newPath.slice(1).reverse()];
                                        return {
                                            found: true,
                                            path: completePath,
                                            length: completePath.length - 1,
                                            pagesExplored
                                        };
                                    }
                                }
                            }
                        }
                    }

                    depth++;
                }

                return { found: false, path: null, length: null, pagesExplored };
            }

            async getBestNextLink(currentPage, targetPage) {
                console.log('[getBestNextLink] Called with:', { currentPage, targetPage });
                const result = await this.findShortestPath(currentPage, targetPage, 4);
                console.log('[getBestNextLink] Path found:', result.path);

                if (!result.found || !result.path || result.path.length < 2) {
                    console.log('[getBestNextLink] No valid path found');
                    return { success: false, message: 'Could not find optimal path' };
                }

                console.log('[getBestNextLink] Returning path[1]:', result.path[1]);
                return {
                    success: true,
                    bestLink: result.path[1],
                    optimalPath: result.path,
                    optimalLength: result.length,
                    hint: `Try clicking: "${result.path[1]}"`
                };
            }
        }

        // Create global instance
        const wikipathSolver = new WikipathSolverBrowser();
        console.log('‚úì Wikipedia Path Solver ready!');

        // Store optimal path globally
        let optimalPathData = null;

        // Show hint using the solver
        async function showSolverHint() {
            console.log('=== showSolverHint called ===');
            if (!gameState.currentPage || !gameState.targetPage || gameState.hasWon) {
                showNotification('Hint not available right now');
                console.log('Hint blocked:', { currentPage: gameState.currentPage, targetPage: gameState.targetPage, hasWon: gameState.hasWon });
                return;
            }

            const minClicksDisplay = document.getElementById('min-clicks-display');
            const originalText = minClicksDisplay.textContent;
            minClicksDisplay.textContent = '...';
            minClicksDisplay.classList.add('loading');

            try {
                console.log('=== HINT REQUEST ===');
                console.log('Current page:', gameState.currentPage);
                console.log('Target page:', gameState.targetPage);
                console.log('Getting hint from solver...');
                const hint = await wikipathSolver.getBestNextLink(
                    gameState.currentPage,
                    gameState.targetPage
                );
                console.log('Hint result:', hint);
                console.log('Suggested next link:', hint.bestLink);
                if (hint.optimalPath) {
                    console.log('Full path:', hint.optimalPath.join(' ‚Üí '));
                }

                if (hint.success) {
                    // SAFETY CHECK: Don't suggest the current page
                    const normalizedBestLink = hint.bestLink.replace(/_/g, ' ').trim().toLowerCase();
                    const normalizedCurrentPage = gameState.currentPage.replace(/_/g, ' ').trim().toLowerCase();
                    
                    if (normalizedBestLink === normalizedCurrentPage) {
                        console.error('‚ö†Ô∏è BUG DETECTED: Hint is suggesting current page!');
                        console.error('Current page:', gameState.currentPage);
                        console.error('Suggested link:', hint.bestLink);
                        console.error('Full path:', hint.optimalPath);
                        showNotification('‚ö†Ô∏è Hint error: Already on suggested page. Try again.');
                        minClicksDisplay.textContent = originalText;
                        minClicksDisplay.classList.remove('loading');
                        return;
                    }
                    
                    // Find the link on the page using the data-page-title attribute
                    const allLinks = document.querySelectorAll('#game-area a[data-page-title]');
                    console.log('Total links with data-page-title:', allLinks.length);
                    
                    // Debug: log first few links
                    if (allLinks.length > 0) {
                        console.log('First 5 links:', Array.from(allLinks).slice(0, 5).map(l => l.getAttribute('data-page-title')));
                    }
                    
                    let foundLink = null;
                    
                    // The hint.bestLink might have spaces or underscores, normalize both for comparison
                    const normalizedHint = hint.bestLink.replace(/_/g, ' ');
                    console.log('Looking for:', normalizedHint);
                    
                    for (const link of allLinks) {
                        const pageTitle = link.getAttribute('data-page-title');
                        const normalizedPageTitle = pageTitle.replace(/_/g, ' ');
                        
                        if (normalizedPageTitle === normalizedHint) {
                            foundLink = link;
                            console.log('‚úì Found link!');
                            break;
                        }
                    }
                    
                    if (foundLink) {
                        console.log('Scrolling and highlighting link...');
                        // Scroll to the link smoothly
                        foundLink.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                        
                        // Add gold highlight
                        foundLink.classList.add('hint-highlight');
                        console.log('Highlight class added');
                        
                        // Show notification
                        showNotification(`üí° Hint: Highlighted on page`);
                        
                        // Remove highlight after 3 seconds
                        setTimeout(() => {
                            foundLink.classList.remove('hint-highlight');
                            console.log('Highlight removed');
                        }, 3000);
                    } else {
                        // Link not found on page (might be further down and need scrolling/loading)
                        showNotification(`üí° Hint: Look for "${hint.bestLink}"`);
                        console.log('‚ö† Link not found on current page view:', hint.bestLink);
                        console.log('All available links:', Array.from(allLinks).map(l => l.getAttribute('data-page-title')));
                    }
                    
                    console.log('Optimal path:', hint.optimalPath.join(' ‚Üí '));
                } else {
                    showNotification('Could not generate hint');
                    console.log('Hint generation failed');
                }
            } catch (error) {
                console.error('Hint error:', error);
                showNotification('Error generating hint');
            } finally {
                minClicksDisplay.textContent = originalText;
                minClicksDisplay.classList.remove('loading');
            }
        }

        // Calculate minimum clicks when game starts
        async function calculateMinimumClicks(startPage, targetPage) {
            const minClicksDisplay = document.getElementById('min-clicks-display');
            minClicksDisplay.textContent = '...';
            minClicksDisplay.classList.add('loading');

            try {
                console.log('Calculating minimum clicks...');
                const result = await wikipathSolver.findShortestPath(startPage, targetPage, 5);
                
                if (result.found) {
                    optimalPathData = result;
                    minClicksDisplay.textContent = result.length;
                    minClicksDisplay.classList.remove('loading');
                    console.log(`‚úì Minimum: ${result.length} clicks`);
                    console.log(`‚úì Path: ${result.path.join(' ‚Üí ')}`);
                } else {
                    optimalPathData = null;
                    minClicksDisplay.textContent = '?';
                    minClicksDisplay.classList.remove('loading');
                    console.log('Could not find path within 5 degrees');
                }
            } catch (error) {
                console.error('Error calculating minimum clicks:', error);
                optimalPathData = null;
                minClicksDisplay.textContent = '?';
                minClicksDisplay.classList.remove('loading');
            }
        }

        // ======================
        // CONFIGURATION
        // ======================
        
        // Feature Flags
        const SHOW_DEBUG_MODE = true;
        
        // Initialize debug mode visibility
        if (SHOW_DEBUG_MODE) {
            document.addEventListener('DOMContentLoaded', () => {
                document.getElementById('debug-toggle').style.display = 'inline-block';
                
                const debugMode = localStorage.getItem('wikipath_debug_mode') === 'true';
                if (debugMode) {
                    document.getElementById('debug-toggle').classList.add('active');
                    document.getElementById('debug-panel').classList.add('active');
                }
                
                setupAutocomplete('debug-start-page', 'autocomplete-start');
                setupAutocomplete('debug-target-page', 'autocomplete-target');
                setupAutocomplete('debug-preview-page', 'autocomplete-preview');
            });
        }
        
        // ======================
        // DAILY CHALLENGE SYSTEM
        // ======================
        
        function getTodayDateString() {
            const today = new Date();
            return today.toISOString().split('T')[0];
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function dateToSeed(dateString) {
            return dateString.split('-').map(Number).reduce((acc, val) => acc * 100 + val, 0);
        }

        function getSeededRandomIndex(array, seed, offset = 0) {
            const adjustedSeed = seed + offset;
            return Math.floor(seededRandom(adjustedSeed) * array.length);
        }

        const POPULAR_PAGES = {
            easy: [
                "United States", "World War II", "Python (programming language)",
                "Solar System", "Moon", "Sun", "Earth", "Water",
                "Dog", "Cat", "Football", "Basketball", "Music",
                "Internet", "Google", "Apple Inc.", "Microsoft",
                "New York City", "London", "Paris", "Pizza", "Coffee"
            ],
            medium: [
                "Albert Einstein", "William Shakespeare", "Leonardo da Vinci",
                "DNA", "Climate change", "Artificial intelligence", "The Beatles",
                "Mars", "Isaac Newton", "Charles Darwin", "Quantum mechanics",
                "Renaissance", "French Revolution", "Industrial Revolution",
                "Tiger", "Lion", "Elephant", "Blue whale", "Amazon rainforest",
                "Mount Everest", "Pacific Ocean", "European Union", "United Nations",
                "Olympic Games", "Chess", "Guitar", "Piano", "Vincent van Gogh",
                "Pablo Picasso", "Mona Lisa", "Beethoven", "Mozart", "Star Wars",
                "Harry Potter", "The Lord of the Rings", "Facebook", "Twitter",
                "Great Wall of China", "Eiffel Tower", "Statue of Liberty",
                "Pyramids of Giza", "Taj Mahal", "Machu Picchu", "Colosseum"
            ],
            hard: [
                "Ancient Rome", "Democracy", "Capitalism", "Socialism",
                "Philosophy", "Psychology", "Mathematics", "Physics",
                "Chemistry", "Biology", "Medicine", "Computer", "Smartphone",
                "Electric car", "Space exploration", "International Space Station",
                "Hubble Space Telescope", "Big Bang", "Black hole", "Galaxy",
                "Milky Way", "Jupiter", "Saturn", "Dinosaur", "Evolution",
                "Photosynthesis", "Periodic table", "Napoleon", "Julius Caesar",
                "Cleopatra", "Alexander the Great", "Genghis Khan",
                "Abraham Lincoln", "George Washington", "Martin Luther King Jr.",
                "Mahatma Gandhi", "Nelson Mandela", "Winston Churchill"
            ],
            expert: [
                "COVID-19 pandemic", "Game of Thrones", "Netflix",
                "Chocolate", "Tea", "Sushi", "Pasta", "Rice", "Bread",
                "Potato", "Tomato", "Wine", "Beer", "Tokyo", "Beijing",
                "Rome", "Athens", "Cairo", "Istanbul", "Moscow",
                "Amazon (company)", "Tesla, Inc.", "SpaceX", "NASA", "Nobel Prize",
                "Adolf Hitler"
            ]
        };

        const ALL_PAGES = [
            ...POPULAR_PAGES.easy,
            ...POPULAR_PAGES.medium,
            ...POPULAR_PAGES.hard,
            ...POPULAR_PAGES.expert
        ];

        function getPageDifficulty(pageName) {
            for (const [difficulty, pages] of Object.entries(POPULAR_PAGES)) {
                if (pages.includes(pageName)) {
                    return difficulty;
                }
            }
            return 'medium';
        }

        function calculateChallengeDifficulty(startPage, targetPage) {
            const startDiff = getPageDifficulty(startPage);
            const targetDiff = getPageDifficulty(targetPage);
            
            const difficultyScore = {
                'easy': 1,
                'medium': 2,
                'hard': 3,
                'expert': 4
            };
            
            const avgScore = (difficultyScore[startDiff] + difficultyScore[targetDiff]) / 2;
            
            if (avgScore <= 1.5) return 'easy';
            if (avgScore <= 2.5) return 'medium';
            if (avgScore <= 3.5) return 'hard';
            return 'expert';
        }

        // ======================
        // STATISTICS SYSTEM
        // ======================
        const stats = {
            totalGamesPlayed: 0,
            totalWins: 0,
            totalGiveUps: 0,
            bestClicks: null,
            bestTime: null,
            averageClicks: 0,
            averageTime: 0,
            dailyStreak: 0,
            lastDailyDate: null,
            recentGames: [],
            
            load() {
                const saved = localStorage.getItem('wikipath_stats');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(this, data);
                }
            },
            
            save() {
                const data = {
                    totalGamesPlayed: this.totalGamesPlayed,
                    totalWins: this.totalWins,
                    totalGiveUps: this.totalGiveUps,
                    bestClicks: this.bestClicks,
                    bestTime: this.bestTime,
                    averageClicks: this.averageClicks,
                    averageTime: this.averageTime,
                    dailyStreak: this.dailyStreak,
                    lastDailyDate: this.lastDailyDate,
                    recentGames: this.recentGames
                };
                localStorage.setItem('wikipath_stats', JSON.stringify(data));
            },
            
            recordGame(won, clicks, timeInSeconds, path, mode, gaveUp = false) {
                this.totalGamesPlayed++;
                
                if (won) {
                    this.totalWins++;
                    
                    if (this.bestClicks === null || clicks < this.bestClicks) {
                        this.bestClicks = clicks;
                    }
                    
                    if (this.bestTime === null || timeInSeconds < this.bestTime) {
                        this.bestTime = timeInSeconds;
                    }
                    
                    if (mode === 'daily') {
                        const today = getTodayDateString();
                        if (this.lastDailyDate) {
                            const yesterday = new Date();
                            yesterday.setDate(yesterday.getDate() - 1);
                            const yesterdayStr = yesterday.toISOString().split('T')[0];
                            
                            if (this.lastDailyDate === yesterdayStr) {
                                this.dailyStreak++;
                            } else if (this.lastDailyDate !== today) {
                                this.dailyStreak = 1;
                            }
                        } else {
                            this.dailyStreak = 1;
                        }
                        this.lastDailyDate = today;
                    }
                }
                
                if (gaveUp) {
                    this.totalGiveUps++;
                }
                
                if (won) {
                    const totalClicksSum = this.averageClicks * (this.totalWins - 1) + clicks;
                    this.averageClicks = Math.round(totalClicksSum / this.totalWins * 10) / 10;
                    
                    const totalTimeSum = this.averageTime * (this.totalWins - 1) + timeInSeconds;
                    this.averageTime = Math.round(totalTimeSum / this.totalWins);
                }
                
                this.recentGames.unshift({
                    date: new Date().toISOString(),
                    won,
                    clicks,
                    time: timeInSeconds,
                    pathLength: path.length,
                    mode,
                    gaveUp
                });
                
                if (this.recentGames.length > 10) {
                    this.recentGames = this.recentGames.slice(0, 10);
                }
                
                this.save();
            },
            
            reset() {
                if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                    localStorage.removeItem('wikipath_stats');
                    this.totalGamesPlayed = 0;
                    this.totalWins = 0;
                    this.totalGiveUps = 0;
                    this.bestClicks = null;
                    this.bestTime = null;
                    this.averageClicks = 0;
                    this.averageTime = 0;
                    this.dailyStreak = 0;
                    this.lastDailyDate = null;
                    this.recentGames = [];
                    this.save();
                    alert('Statistics reset successfully!');
                }
            }
        };

        stats.load();

        // ======================
        // GAME STATE
        // ======================
        const gameState = {
            startPage: '',
            targetPage: '',
            currentPage: '',
            clickCount: 0,
            totalClicks: 0,
            visitedPages: new Set(),
            path: [],
            startTime: null,
            elapsedTime: 0,
            isDailyMode: localStorage.getItem('wikipath_mode') === 'explore' ? false : true,
            dailyDate: getTodayDateString(),
            startDescription: '',
            targetDescription: '',
            hasWon: false,
            gaveUp: false,
            difficulty: 'medium'
        };

        // ======================
        // URL STATE MANAGEMENT
        // ======================
        function updateUrl(start, target, current, clicks, totalClicks, visited, path, startTime) {
            const params = new URLSearchParams();
            params.set('start', start);
            params.set('target', target);
            params.set('current', current);
            params.set('clicks', clicks);
            params.set('totalClicks', totalClicks);
            params.set('visited', visited.join(','));
            params.set('path', path.join(','));
            params.set('startTime', startTime);
            
            if (gameState.isDailyMode) {
                params.set('daily', gameState.dailyDate);
            }
            
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({}, '', newUrl);
        }

        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                start: params.get('start'),
                target: params.get('target'),
                current: params.get('current'),
                clicks: parseInt(params.get('clicks')) || 0,
                totalClicks: parseInt(params.get('totalClicks')) || 0,
                visited: params.get('visited') ? params.get('visited').split(',') : [],
                path: params.get('path') ? params.get('path').split(',') : [],
                startTime: parseInt(params.get('startTime')) || Date.now(),
                daily: params.get('daily')
            };
        }

        function clearUrl() {
            window.history.pushState({}, '', window.location.pathname);
        }

        // ======================
        // MODE SWITCHING
        // ======================
        function switchToExploreMode() {
            if (!gameState.isDailyMode) return;
            
            gameState.isDailyMode = false;
            localStorage.setItem('wikipath_mode', 'explore');
            
            const savedExploreStart = localStorage.getItem('wikipath_explore_start');
            const savedExploreTarget = localStorage.getItem('wikipath_explore_target');
            
            if (savedExploreStart && savedExploreTarget) {
                clearUrl();
                const params = new URLSearchParams();
                params.set('start', savedExploreStart);
                params.set('target', savedExploreTarget);
                params.set('current', savedExploreStart);
                params.set('clicks', '0');
                params.set('totalClicks', '0');
                params.set('visited', savedExploreStart);
                params.set('path', savedExploreStart);
                params.set('startTime', Date.now().toString());
                
                const newUrl = `${window.location.pathname}?${params.toString()}`;
                window.location.href = newUrl;
            } else {
                clearUrl();
                location.reload();
            }
        }

        function switchToDailyMode() {
            if (gameState.isDailyMode) return;
            
            if (!gameState.isDailyMode && gameState.startPage && gameState.targetPage) {
                localStorage.setItem('wikipath_explore_start', gameState.startPage);
                localStorage.setItem('wikipath_explore_target', gameState.targetPage);
            }
            
            gameState.isDailyMode = true;
            gameState.dailyDate = getTodayDateString();
            localStorage.setItem('wikipath_mode', 'daily');
            
            clearUrl();
            location.reload();
        }

        function updateModeUI() {
            const exploreBtn = document.getElementById('explore-mode-btn');
            const dailyBtn = document.getElementById('daily-mode-btn');
            const newGameBtn = document.getElementById('new-game-btn');

            if (gameState.isDailyMode) {
                exploreBtn.classList.remove('active');
                dailyBtn.classList.add('active');
                
                if (newGameBtn) {
                    newGameBtn.classList.add('disabled');
                    newGameBtn.title = 'New Game not available in Daily mode - switch to Explore mode';
                }
            } else {
                exploreBtn.classList.add('active');
                dailyBtn.classList.remove('active');
                
                if (newGameBtn) {
                    newGameBtn.classList.remove('disabled');
                    newGameBtn.title = '';
                }
            }
        }

        function handleNewGame() {
            if (gameState.isDailyMode) {
                alert('New Game is not available in Daily mode.\n\nSwitch to Explore mode if you want to start a new random challenge.');
                return;
            }
            
            localStorage.removeItem('wikipath_explore_start');
            localStorage.removeItem('wikipath_explore_target');
            
            startNewGame();
        }

        // ======================
        // WIKIPEDIA API
        // ======================
        async function fetchWikipediaPage(title) {
            const endpoint = 'https://en.wikipedia.org/w/api.php';
            const params = new URLSearchParams({
                action: 'parse',
                page: title,
                format: 'json',
                origin: '*',
                prop: 'text|sections',
                disabletoc: '1',
                redirects: '1'
            });

            try {
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.info);
                }

                return data.parse;
            } catch (error) {
                console.error('Error fetching Wikipedia page:', error);
                throw error;
            }
        }

        async function fetchPageDescription(title) {
            const endpoint = 'https://en.wikipedia.org/w/api.php';
            const params = new URLSearchParams({
                action: 'query',
                titles: title,
                format: 'json',
                origin: '*',
                prop: 'extracts',
                exintro: true,
                explaintext: true,
                exsentences: 2
            });

            try {
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                
                if (pageId === '-1') {
                    return '';
                }
                
                return pages[pageId].extract || '';
            } catch (error) {
                console.error('Error fetching page description:', error);
                return '';
            }
        }

        async function getRandomWikipediaPage() {
            const randomIndex = Math.floor(Math.random() * ALL_PAGES.length);
            return ALL_PAGES[randomIndex];
        }

        async function getDailyWikipediaPages() {
            const seed = dateToSeed(gameState.dailyDate);
            
            const startIndex = getSeededRandomIndex(ALL_PAGES, seed, 0);
            const startPage = ALL_PAGES[startIndex];
            
            let targetIndex;
            do {
                targetIndex = getSeededRandomIndex(ALL_PAGES, seed, 1000);
            } while (targetIndex === startIndex);
            const targetPage = ALL_PAGES[targetIndex];
            
            return { startPage, targetPage };
        }

        // ======================
        // HINT SYSTEM
        // ======================
        function showHint(currentPage) {
            const hintBadge = document.getElementById('hint-badge');
            const hintIcon = document.getElementById('hint-icon');
            const hintText = document.getElementById('hint-text');
            
            if (!hintBadge || !gameState.targetPage) return;
            
            const currentWords = currentPage.toLowerCase().split(/[\s_\-()]+/);
            const targetWords = gameState.targetPage.toLowerCase().split(/[\s_\-()]+/);
            
            const commonWords = currentWords.filter(word => 
                word.length > 3 && targetWords.includes(word)
            ).length;
            
            hintBadge.className = 'hint-badge active';
            
            if (commonWords >= 2) {
                hintBadge.classList.add('hot');
                hintIcon.textContent = 'üî•';
                hintText.textContent = "You're very close!";
            } else if (commonWords === 1) {
                hintBadge.classList.add('warmer');
                hintIcon.textContent = 'üå°Ô∏è';
                hintText.textContent = 'Getting warmer!';
            } else if (gameState.path.length > 5) {
                hintBadge.classList.add('colder');
                hintIcon.textContent = '‚ùÑÔ∏è';
                hintText.textContent = 'Try a different direction';
            } else {
                hintBadge.classList.add('warmer');
                hintIcon.textContent = 'üß≠';
                hintText.textContent = 'Keep exploring!';
            }
            
            setTimeout(() => {
                hintBadge.classList.remove('active');
            }, 3000);
        }

        // ======================
        // GAME CONTROLLER
        // ======================
        class GameController {
            constructor() {
                this.gameArea = document.getElementById('game-area');
                this.clickCounter = document.getElementById('click-counter');
                this.timerDisplay = document.getElementById('timer');
                this.targetPageDisplay = document.getElementById('target-page-display');
                this.tocContainer = document.getElementById('toc-list');
                this.timerInterval = null;
            }

            async initialize() {
                const urlParams = getUrlParams();
                
                if (urlParams.start && urlParams.target) {
                    if (urlParams.daily) {
                        gameState.isDailyMode = true;
                        gameState.dailyDate = urlParams.daily;
                        
                        if (urlParams.daily !== getTodayDateString()) {
                            gameState.dailyDate = getTodayDateString();
                            await this.startNewDailyChallenge();
                            return;
                        }
                    } else {
                        gameState.isDailyMode = false;
                    }
                    
                    gameState.startPage = urlParams.start;
                    gameState.targetPage = urlParams.target;
                    gameState.currentPage = urlParams.current || urlParams.start;
                    gameState.clickCount = urlParams.clicks;
                    gameState.totalClicks = urlParams.totalClicks;
                    gameState.visitedPages = new Set(urlParams.visited);
                    gameState.path = urlParams.path.length > 0 ? urlParams.path : [urlParams.start];
                    gameState.startTime = urlParams.startTime;
                    
                    updateModeUI();
                    
                    gameState.targetDescription = await fetchPageDescription(gameState.targetPage);
                    
                    this.updateDisplay();
                    this.updatePathDisplay();
                    this.startTimer();
                    
                    // NEW: Calculate minimum clicks for resumed game
                    calculateMinimumClicks(gameState.startPage, gameState.targetPage);
                    
                    await this.loadPage(gameState.currentPage);
                } else {
                    if (gameState.isDailyMode) {
                        await this.startNewDailyChallenge();
                    } else {
                        await this.startNewExploreGame();
                    }
                }
            }

            async startNewDailyChallenge() {
                const { startPage, targetPage } = await getDailyWikipediaPages();
                
                gameState.startPage = startPage;
                gameState.targetPage = targetPage;
                gameState.currentPage = startPage;
                gameState.clickCount = 0;
                gameState.totalClicks = 0;
                gameState.visitedPages = new Set([startPage]);
                gameState.path = [startPage];
                gameState.startTime = Date.now();
                gameState.hasWon = false;
                gameState.gaveUp = false;
                gameState.difficulty = calculateChallengeDifficulty(startPage, targetPage);
                
                updateModeUI();
                
                gameState.targetDescription = await fetchPageDescription(targetPage);
                
                this.updateDisplay();
                this.updatePathDisplay();
                this.startTimer();
                
                // NEW: Calculate minimum clicks
                calculateMinimumClicks(startPage, targetPage);
                
                updateUrl(
                    startPage,
                    targetPage,
                    startPage,
                    0,
                    0,
                    [startPage],
                    [startPage],
                    gameState.startTime
                );
                
                await this.loadPage(startPage);
            }

            async startNewExploreGame() {
                const startPage = await getRandomWikipediaPage();
                let targetPage;
                do {
                    targetPage = await getRandomWikipediaPage();
                } while (targetPage === startPage);

                gameState.startPage = startPage;
                gameState.targetPage = targetPage;
                gameState.currentPage = startPage;
                gameState.clickCount = 0;
                gameState.totalClicks = 0;
                gameState.visitedPages = new Set([startPage]);
                gameState.path = [startPage];
                gameState.startTime = Date.now();
                gameState.hasWon = false;
                gameState.gaveUp = false;
                gameState.difficulty = calculateChallengeDifficulty(startPage, targetPage);
                
                localStorage.setItem('wikipath_explore_start', startPage);
                localStorage.setItem('wikipath_explore_target', targetPage);

                updateModeUI();

                gameState.targetDescription = await fetchPageDescription(targetPage);

                this.updateDisplay();
                this.updatePathDisplay();
                this.startTimer();

                // NEW: Calculate minimum clicks
                calculateMinimumClicks(startPage, targetPage);

                updateUrl(
                    startPage,
                    targetPage,
                    startPage,
                    0,
                    0,
                    [startPage],
                    [startPage],
                    gameState.startTime
                );

                await this.loadPage(startPage);
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    const elapsed = Date.now() - gameState.startTime;
                    const seconds = Math.floor(elapsed / 1000);
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    this.timerDisplay.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
            }

            updatePathDisplay() {
                const pathTimeline = document.getElementById('path-timeline');
                pathTimeline.innerHTML = '';
                
                gameState.path.forEach((page, index) => {
                    const item = document.createElement('div');
                    item.className = 'path-timeline-item';
                    if (index === gameState.path.length - 1) {
                        item.classList.add('current');
                    }
                    
                    item.innerHTML = `
                        <div class="path-item-number">Step ${index + 1}</div>
                        <div class="path-item-title">${page}</div>
                    `;
                    
                    pathTimeline.appendChild(item);
                });
            }

            async loadPage(title) {
                this.gameArea.innerHTML = '<div class="loading">Loading Wikipedia article...</div>';
                this.tocContainer.innerHTML = '';

                try {
                    const pageData = await fetchWikipediaPage(title);
                    
                    const actualPageTitle = pageData.title;
                    
                    if (actualPageTitle !== title) {
                        console.log(`Redirect: ${title} -> ${actualPageTitle}`);
                        gameState.currentPage = actualPageTitle;
                        
                        if (gameState.path[gameState.path.length - 1] === title) {
                            gameState.path[gameState.path.length - 1] = actualPageTitle;
                        }
                        
                        updateUrl(
                            gameState.startPage,
                            gameState.targetPage,
                            gameState.currentPage,
                            gameState.clickCount,
                            gameState.totalClicks,
                            Array.from(gameState.visitedPages),
                            gameState.path,
                            gameState.startTime
                        );
                        
                        const normalizedCurrent = actualPageTitle.trim().toLowerCase().replace(/_/g, ' ');
                        const normalizedTarget = gameState.targetPage.trim().toLowerCase().replace(/_/g, ' ');
                        
                        if (normalizedCurrent === normalizedTarget) {
                            this.showWinScreen();
                            return;
                        }
                    }
                    
                    this.renderPage(pageData);
                    this.buildTableOfContents(pageData.sections);
                } catch (error) {
                    this.showError(`Failed to load page: ${error.message}`);
                }
            }

            buildTableOfContents(sections) {
                if (!sections || sections.length === 0) {
                    this.tocContainer.innerHTML = '<li style="color: #999; font-size: 0.9em;">No sections available</li>';
                    return;
                }

                this.tocContainer.innerHTML = '';
                
                const sectionGroups = {};
                let currentH1 = null;
                
                sections.forEach(section => {
                    if (section.toclevel === 1) {
                        currentH1 = section.line;
                        sectionGroups[currentH1] = {
                            header: section,
                            subsections: []
                        };
                    } else if (section.toclevel === 2 && currentH1) {
                        sectionGroups[currentH1].subsections.push(section);
                    }
                });
                
                Object.entries(sectionGroups).forEach(([h1Title, group]) => {
                    const li = document.createElement('li');
                    li.className = 'toc-item';
                    
                    const hasSubsections = group.subsections.length > 0;
                    
                    const header = document.createElement('div');
                    header.className = hasSubsections ? 'toc-section-header collapsed' : 'toc-section-header no-children';
                    
                    if (hasSubsections) {
                        header.innerHTML = `
                            <span class="toc-collapse-icon">‚ñº</span>
                            <span>${h1Title}</span>
                        `;
                    } else {
                        header.innerHTML = `<span>${h1Title}</span>`;
                    }
                    
                    const subsectionsList = document.createElement('ul');
                    subsectionsList.className = 'toc-subsections collapsed';
                    
                    header.addEventListener('click', (e) => {
                        if (hasSubsections) {
                            header.classList.toggle('collapsed');
                            subsectionsList.classList.toggle('collapsed');
                        }
                        
                        const heading = document.getElementById(group.header.anchor);
                        if (heading) {
                            heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                    
                    group.subsections.forEach(subsection => {
                        const subLi = document.createElement('li');
                        subLi.className = 'toc-item';
                        
                        const link = document.createElement('a');
                        link.className = 'toc-link';
                        link.textContent = subsection.line;
                        
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const heading = document.getElementById(subsection.anchor);
                            if (heading) {
                                heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                
                                document.querySelectorAll('.toc-link').forEach(l => l.classList.remove('active'));
                                link.classList.add('active');
                            }
                        });
                        
                        subLi.appendChild(link);
                        subsectionsList.appendChild(subLi);
                    });
                    
                    li.appendChild(header);
                    if (hasSubsections) {
                        li.appendChild(subsectionsList);
                    }
                    this.tocContainer.appendChild(li);
                });
            }

            renderPage(pageData) {
                const articleDiv = document.createElement('div');
                articleDiv.className = 'wikipedia-article';
                
                let htmlContent = pageData.text['*'];
                
                htmlContent = htmlContent.replace(/src="\/\//g, 'src="https://');
                htmlContent = htmlContent.replace(/srcset="\/\//g, 'srcset="https://');
                htmlContent = htmlContent.replace(/src="\/(?!\/)/g, 'src="https://en.wikipedia.org/');
                htmlContent = htmlContent.replace(/srcset="\/(?!\/)/g, 'srcset="https://en.wikipedia.org/');
                
                articleDiv.innerHTML = htmlContent;

                articleDiv.querySelectorAll('.ambox, .hatnote, .dablink, .rellink').forEach(el => el.remove());
                articleDiv.querySelectorAll('.hatnote, [class*="hatnote"]').forEach(el => el.remove());
                articleDiv.querySelectorAll('.mw-editsection, [class*="editsection"]').forEach(el => el.remove());
                
                if (gameState.currentPage === gameState.startPage && gameState.path.length === 1) {
                    const indicator = document.createElement('div');
                    indicator.className = 'starting-page-indicator';
                    indicator.innerHTML = `
                        <div class="icon">üöÄ</div>
                        <div class="text">
                            <div class="label">Starting Point</div>
                            <div class="description">Your journey begins here. Find your way to "<strong>${gameState.targetPage}</strong>" by following the links.</div>
                        </div>
                    `;
                    
                    const firstElement = articleDiv.firstElementChild;
                    if (firstElement) {
                        articleDiv.insertBefore(indicator, firstElement);
                    } else {
                        articleDiv.appendChild(indicator);
                    }
                }
                
                let h1 = articleDiv.querySelector('h1');
                if (!h1) {
                    h1 = document.createElement('h1');
                    h1.textContent = pageData.title;
                    
                    const startingIndicator = articleDiv.querySelector('.starting-page-indicator');
                    if (startingIndicator && startingIndicator.nextSibling) {
                        articleDiv.insertBefore(h1, startingIndicator.nextSibling);
                    } else if (startingIndicator) {
                        articleDiv.appendChild(h1);
                    } else {
                        const firstElement = articleDiv.firstElementChild;
                        if (firstElement) {
                            articleDiv.insertBefore(h1, firstElement);
                        } else {
                            articleDiv.appendChild(h1);
                        }
                    }
                }
                
                const noticesContainer = document.createElement('div');
                noticesContainer.className = 'article-notices-container';
                
                const hasVerificationIssue = 
                    pageData.text['*'].includes('This article needs additional citations') ||
                    pageData.text['*'].includes('needs additional verification') ||
                    pageData.text['*'].includes('lacks sufficient inline citations') ||
                    pageData.text['*'].includes('cite check') ||
                    (pageData.text['*'].includes('ambox-content') && pageData.text['*'].includes('citation'));
                
                if (hasVerificationIssue) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice verification';
                    notice.textContent = '‚ö†Ô∏è';
                    notice.setAttribute('data-tooltip', 'This article may need additional verification');
                    noticesContainer.appendChild(notice);
                }
                
                if (pageData.text['*'].includes('current event') || pageData.text['*'].includes('recently updated')) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice recent-changes';
                    notice.textContent = 'üìù';
                    notice.setAttribute('data-tooltip', 'This article has been recently updated');
                    noticesContainer.appendChild(notice);
                }
                
                if (pageData.text['*'].includes('recently died') || pageData.text['*'].includes('recent death')) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice recent-death';
                    notice.textContent = 'üïäÔ∏è';
                    notice.setAttribute('data-tooltip', 'Subject recently deceased');
                    noticesContainer.appendChild(notice);
                }
                
                if (noticesContainer.children.length > 0 && h1) {
                    const h1Container = document.createElement('div');
                    h1Container.style.position = 'relative';
                    
                    const h1Parent = h1.parentNode;
                    h1Parent.insertBefore(h1Container, h1);
                    h1Container.appendChild(h1);
                    h1Container.appendChild(noticesContainer);
                }

                this.gameArea.innerHTML = '';
                this.gameArea.appendChild(articleDiv);

                this.processLinks();
                this.fixImages();
            }

            fixImages() {
                const images = this.gameArea.querySelectorAll('img');
                images.forEach(img => {
                    const src = img.getAttribute('src');
                    
                    if (!src) return;
                    
                    if (src.startsWith('//')) {
                        img.setAttribute('src', 'https:' + src);
                    } 
                    else if (src.startsWith('/') && !src.startsWith('//')) {
                        img.setAttribute('src', 'https://en.wikipedia.org' + src);
                    }
                    else if (src.startsWith('data:') || src.startsWith('http:') || src.startsWith('https:')) {
                        // Already valid
                    }
                    else if (!src.includes('://')) {
                        img.setAttribute('src', 'https://en.wikipedia.org/' + src);
                    }
                    
                    img.onerror = function() {
                        console.warn('Failed to load image:', this.src);
                        this.style.display = 'none';
                    };
                });
            }

            processLinks() {
                const links = this.gameArea.querySelectorAll('a');
                
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    
                    if (href && href.startsWith('/wiki/') && !href.includes(':')) {
                        let pageTitle;
                        try {
                            pageTitle = decodeURIComponent(href.replace('/wiki/', ''));
                        } catch (e) {
                            // If decoding fails (malformed URI), use the raw title
                            console.warn('Failed to decode URI:', href, e);
                            pageTitle = href.replace('/wiki/', '');
                        }
                        
                        // Store pageTitle as data attribute for later reference (e.g., for hints)
                        link.setAttribute('data-page-title', pageTitle);
                        
                        link.removeAttribute('href');
                        link.style.cursor = 'pointer';
                        
                        if (gameState.visitedPages.has(pageTitle)) {
                            link.classList.add('visited-link');
                        }
                        
                        if (pageTitle.includes('(disambiguation)') || 
                            link.textContent.toLowerCase().includes('disambiguation')) {
                            link.classList.add('disambiguation-link');
                        }
                        
                        let previewTimeout = null;
                        let previewCache = {};
                        
                        link.addEventListener('mouseenter', async (e) => {
                            previewTimeout = setTimeout(async () => {
                                const preview = document.getElementById('link-preview');
                                const previewTitle = document.getElementById('preview-title');
                                const previewText = document.getElementById('preview-text');
                                
                                previewTitle.textContent = pageTitle;
                                previewText.innerHTML = '<span class="link-preview-loading">Loading preview...</span>';
                                preview.classList.add('active');
                                
                                if (!previewCache[pageTitle]) {
                                    try {
                                        const description = await fetchPageDescription(pageTitle);
                                        previewCache[pageTitle] = description || 'No preview available.';
                                    } catch (error) {
                                        previewCache[pageTitle] = 'Preview unavailable.';
                                    }
                                }
                                
                                if (preview.classList.contains('active')) {
                                    previewText.textContent = previewCache[pageTitle].substring(0, 200) + '...';
                                }
                            }, 500);
                        });
                        
                        link.addEventListener('mousemove', (e) => {
                            const preview = document.getElementById('link-preview');
                            if (preview.classList.contains('active')) {
                                let left = e.clientX + 15;
                                let top = e.clientY + 15;
                                
                                if (left + 350 > window.innerWidth) {
                                    left = e.clientX - 365;
                                }
                                if (top + preview.offsetHeight > window.innerHeight) {
                                    top = e.clientY - preview.offsetHeight - 15;
                                }
                                
                                preview.style.left = left + 'px';
                                preview.style.top = top + 'px';
                            }
                        });
                        
                        link.addEventListener('mouseleave', () => {
                            clearTimeout(previewTimeout);
                            const preview = document.getElementById('link-preview');
                            preview.classList.remove('active');
                        });
                        
                        link.addEventListener('click', async (e) => {
                            e.preventDefault();
                            
                            addClickFeedback(link);
                            
                            const preview = document.getElementById('link-preview');
                            preview.classList.remove('active');
                            
                            if (link.classList.contains('disambiguation-link')) {
                                const confirmed = confirm(`‚ö†Ô∏è WARNING: "${pageTitle}" appears to be a disambiguation page.\n\nDisambiguation pages don't contain actual content - they just list links to other articles with similar names.\n\nDo you want to continue?`);
                                
                                if (!confirmed) {
                                    return;
                                }
                            }
                            
                            this.handleLinkClick(pageTitle);
                        });
                    } else {
                        // Remove non-article links completely from the page
                        link.remove();
                    }
                });
            }

            async handleLinkClick(pageTitle) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                const isNewPage = !gameState.visitedPages.has(pageTitle);
                
                if (isNewPage) {
                    gameState.totalClicks++;
                    gameState.visitedPages.add(pageTitle);
                }
                
                gameState.clickCount++;
                gameState.currentPage = pageTitle;
                gameState.path.push(pageTitle);
                
                showHint(pageTitle);
                
                updateUrl(
                    gameState.startPage,
                    gameState.targetPage,
                    gameState.currentPage,
                    gameState.clickCount,
                    gameState.totalClicks,
                    Array.from(gameState.visitedPages),
                    gameState.path,
                    gameState.startTime
                );
                
                this.updateDisplay();
                this.updatePathDisplay();

                const normalizedCurrent = pageTitle.trim().toLowerCase().replace(/_/g, ' ');
                const normalizedTarget = gameState.targetPage.trim().toLowerCase().replace(/_/g, ' ');
                
                if (normalizedCurrent === normalizedTarget) {
                    this.showWinScreen();
                    return;
                }

                await this.loadPage(pageTitle);
            }

            updateDisplay() {
                this.clickCounter.textContent = gameState.totalClicks;
                this.targetPageDisplay.textContent = gameState.targetPage;
                
                const difficultyBadge = document.getElementById('difficulty-badge');
                difficultyBadge.textContent = gameState.difficulty.toUpperCase();
                difficultyBadge.className = `difficulty-badge difficulty-${gameState.difficulty}`;
                
                if (gameState.targetDescription) {
                    document.getElementById('tooltip-title').textContent = gameState.targetPage;
                    document.getElementById('tooltip-description').textContent = gameState.targetDescription;
                }
            }

            showWinScreen() {
                this.stopTimer();
                gameState.hasWon = true;
                
                createConfetti();
                
                const timeInSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
                
                const mode = gameState.isDailyMode ? 'daily' : 'explore';
                stats.recordGame(true, gameState.totalClicks, timeInSeconds, gameState.path, mode, false);
                
                const modal = document.getElementById('win-modal');
                const finalClicksEl = document.getElementById('final-clicks');
                const finalTimeEl = document.getElementById('final-time');
                const finalPagesEl = document.getElementById('final-pages');
                const winPathEl = document.getElementById('win-path');

                finalClicksEl.textContent = gameState.totalClicks;
                finalTimeEl.textContent = this.timerDisplay.textContent;
                finalPagesEl.textContent = gameState.path.length;

                let rating = '';
                let ratingClass = '';
                
                // NEW: Compare with optimal if available
                if (optimalPathData && optimalPathData.found) {
                    const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                    
                    if (efficiency >= 100) {
                        rating = 'üèÜ PERFECT! Optimal path!';
                        ratingClass = 'rating-perfect';
                    } else if (efficiency >= 80) {
                        rating = 'üåü EXCELLENT! Very close to optimal!';
                        ratingClass = 'rating-excellent';
                    } else if (efficiency >= 60) {
                        rating = 'üëç GOOD! Nice work!';
                        ratingClass = 'rating-good';
                    } else {
                        rating = '‚úÖ COMPLETED! Well done!';
                        ratingClass = 'rating-completed';
                    }
                } else {
                    if (gameState.totalClicks <= 3) {
                        rating = 'üèÜ AMAZING! Perfect score!';
                        ratingClass = 'rating-perfect';
                    } else if (gameState.totalClicks <= 5) {
                        rating = 'üåü EXCELLENT! Great job!';
                        ratingClass = 'rating-excellent';
                    } else if (gameState.totalClicks <= 10) {
                        rating = 'üëç GOOD! Well done!';
                        ratingClass = 'rating-good';
                    } else {
                        rating = '‚úÖ COMPLETED! Nice work!';
                        ratingClass = 'rating-completed';
                    }
                }

                let pathHtml = `<div class="performance-rating ${ratingClass}">${rating}</div>`;
                
                if (stats.bestClicks === gameState.totalClicks && stats.totalWins > 1) {
                    pathHtml += '<div style="text-align: center; background: #fff3cd; padding: 10px; border-radius: 8px; margin-bottom: 15px; color: #856404;"><strong>üéâ New Personal Best!</strong></div>';
                }
                
                // NEW: Show comparison if we have optimal path
                if (optimalPathData && optimalPathData.found && optimalPathData.length !== gameState.totalClicks) {
                    const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                    pathHtml += `
                        <div class="path-comparison">
                            <div class="path-comparison-header">
                                <h3>üìä Path Comparison</h3>
                                <div class="efficiency-badge">${efficiency}% Efficient</div>
                            </div>
                        </div>
                    `;
                }
                
                pathHtml += '<h3>üó∫Ô∏è Your Journey:</h3>';
                gameState.path.forEach((page, index) => {
                    pathHtml += `<div class="path-item">
                        <div class="path-item-number">${index + 1}</div>
                        <div>${page}</div>
                    </div>`;
                });
                
                // NEW: Show optimal path if different
                if (optimalPathData && optimalPathData.found && optimalPathData.length !== gameState.totalClicks) {
                    pathHtml += `<h3 style="margin-top: 25px;">‚ú® Optimal Path (${optimalPathData.length} clicks):</h3>`;
                    optimalPathData.path.forEach((page, index) => {
                        pathHtml += `<div class="path-item optimal">
                            <div class="path-item-number">${index + 1}</div>
                            <div>${page}</div>
                        </div>`;
                    });
                }
                
                winPathEl.innerHTML = pathHtml;

                modal.classList.add('active');
            }

            showError(message) {
                this.gameArea.innerHTML = `<div class="error">${message}</div>`;
            }
        }

        // ======================
        // VISUAL EFFECTS
        // ======================
        
        function createConfetti() {
            const colors = ['#0645ad', '#7c3aed', '#f59e0b', '#10b981', '#ef4444', '#ec4899'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.3 + 's';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        function addClickFeedback(element) {
            element.classList.add('click-feedback');
            setTimeout(() => element.classList.remove('click-feedback'), 200);
        }

        // ======================
        // SHARE FUNCTIONALITY
        // ======================
        function generateShareText() {
            const emoji = gameState.totalClicks <= 3 ? 'üèÜ' : gameState.totalClicks <= 5 ? 'üåü' : gameState.totalClicks <= 10 ? 'üëç' : '‚úÖ';
            
            let modeText = '';
            if (gameState.isDailyMode) {
                const date = new Date(gameState.dailyDate);
                const options = { month: 'short', day: 'numeric', year: 'numeric' };
                modeText = `üìÖ Daily Challenge - ${date.toLocaleDateString('en-US', options)}\n`;
            } else {
                modeText = `üß≠ Explore Mode\n`;
            }
            
            // NEW: Include minimum clicks if available
            let efficiencyText = '';
            if (optimalPathData && optimalPathData.found) {
                const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                efficiencyText = `‚ö° Efficiency: ${efficiency}% (${optimalPathData.length} min)\n`;
            }
            
            const pathVisual = gameState.path.map((page, i) => {
                if (i === 0) return `üéØ ${page}`;
                if (i === gameState.path.length - 1) return `‚úÖ ${page}`;
                return `  ‚Üí ${page}`;
            }).join('\n');
            
            return `${emoji} WikiPath Challenge ${emoji}
${modeText}
${gameState.startPage} ‚ûú ${gameState.targetPage}

üìä Results:
‚úì Clicks: ${gameState.totalClicks}
${efficiencyText}‚è±Ô∏è Time: ${document.getElementById('timer').textContent}
üìÑ Pages: ${gameState.path.length}

üó∫Ô∏è My Path:
${pathVisual}

Play at: ${window.location.origin}${window.location.pathname}`;
        }

        function shareResult() {
            const shareText = generateShareText();
            
            if (navigator.share) {
                navigator.share({
                    title: 'WikiPath Challenge',
                    text: shareText
                }).catch(err => {
                    console.log('Error sharing:', err);
                    copyResultToClipboard();
                });
            } else {
                copyResultToClipboard();
            }
        }

        function copyResultToClipboard() {
            const shareText = generateShareText();
            
            navigator.clipboard.writeText(shareText).then(() => {
                showNotification('Copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                const textArea = document.createElement('textarea');
                textArea.value = shareText;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showNotification('Copied to clipboard!');
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                }
                document.body.removeChild(textArea);
            });
        }

        function showNotification(message = '‚úì Copied to clipboard!') {
            const notification = document.getElementById('share-notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // ======================
        // BROWSER BACK BUTTON HANDLER
        // ======================
        window.addEventListener('popstate', function(event) {
            const urlParams = getUrlParams();
            
            if (urlParams.start && urlParams.target) {
                if (urlParams.daily) {
                    gameState.isDailyMode = true;
                    gameState.dailyDate = urlParams.daily;
                    
                    if (urlParams.daily !== getTodayDateString()) {
                        location.reload();
                        return;
                    }
                } else {
                    gameState.isDailyMode = false;
                }
                
                gameState.startPage = urlParams.start;
                gameState.targetPage = urlParams.target;
                gameState.currentPage = urlParams.current || urlParams.start;
                gameState.clickCount = urlParams.clicks;
                gameState.totalClicks = Math.max(gameState.totalClicks, urlParams.totalClicks);
                gameState.visitedPages = new Set(urlParams.visited);
                gameState.path = urlParams.path.length > 0 ? urlParams.path : [urlParams.start];
                
                updateModeUI();
                game.updateDisplay();
                game.updatePathDisplay();
                game.loadPage(gameState.currentPage);
            }
        });

        // ======================
        // STATISTICS MODAL
        // ======================
        function openStats() {
            updateStatsDisplay();
            const modal = document.getElementById('stats-modal');
            modal.classList.add('active');
        }

        function closeStats() {
            const modal = document.getElementById('stats-modal');
            modal.classList.remove('active');
        }

        function updateStatsDisplay() {
            document.getElementById('stat-streak').textContent = stats.dailyStreak;
            document.getElementById('stat-games').textContent = stats.totalGamesPlayed;
            document.getElementById('stat-wins').textContent = stats.totalWins;
            
            const winRate = stats.totalGamesPlayed > 0 
                ? Math.round((stats.totalWins / stats.totalGamesPlayed) * 100) 
                : 0;
            document.getElementById('stat-winrate').textContent = `${winRate}% win rate`;
            
            document.getElementById('stat-best-clicks').textContent = 
                stats.bestClicks !== null ? stats.bestClicks : '-';
            
            document.getElementById('stat-best-time').textContent = 
                stats.bestTime !== null ? formatTime(stats.bestTime) : '-';
            
            document.getElementById('stat-avg-clicks').textContent = 
                stats.totalWins > 0 ? stats.averageClicks : '-';
            
            document.getElementById('stat-avg-time').textContent = 
                stats.totalWins > 0 ? formatTime(stats.averageTime) : '-';
            
            const recentGamesList = document.getElementById('recent-games-list');
            if (stats.recentGames.length === 0) {
                recentGamesList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No games played yet</p>';
            } else {
                recentGamesList.innerHTML = stats.recentGames.map(game => {
                    const date = new Date(game.date);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                    
                    const resultText = game.gaveUp ? 'Gave Up' : (game.won ? 'Won' : 'Lost');
                    const resultClass = game.gaveUp ? 'gave-up' : '';
                    
                    return `
                        <div class="recent-game-item ${resultClass}">
                            <div class="recent-game-info">
                                <div class="recent-game-result ${resultClass}">${resultText}</div>
                                <div class="recent-game-stats">
                                    <span>üéØ ${game.clicks} clicks</span>
                                    <span>‚è±Ô∏è ${formatTime(game.time)}</span>
                                    <span>${game.mode === 'daily' ? 'üìÖ Daily' : 'üß≠ Explore'}</span>
                                </div>
                            </div>
                            <div class="recent-game-date">${dateStr} ${timeStr}</div>
                        </div>
                    `;
                }).join('');
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ======================
        // FAB MENU TOGGLE
        // ======================
        function toggleFabMenu() {
            const menu = document.getElementById('fab-menu');
            menu.classList.toggle('open');
        }

        function closeFabMenu() {
            const menu = document.getElementById('fab-menu');
            menu.classList.remove('open');
        }

        document.addEventListener('click', (e) => {
            const menu = document.getElementById('fab-menu');
            const menuButton = document.querySelector('.fab-menu-button');
            
            if (menuButton && menuButton.contains(e.target)) {
                return;
            }
            
            if (menu && !menu.contains(e.target)) {
                menu.classList.remove('open');
            }
        });

        // ======================
        // TOC COLLAPSE CONTROLS
        // ======================
        function collapseAllTOC() {
            document.querySelectorAll('.toc-section-header').forEach(header => {
                header.classList.add('collapsed');
            });
            document.querySelectorAll('.toc-subsections').forEach(list => {
                list.classList.add('collapsed');
            });
        }

        function expandAllTOC() {
            document.querySelectorAll('.toc-section-header').forEach(header => {
                header.classList.remove('collapsed');
            });
            document.querySelectorAll('.toc-subsections').forEach(list => {
                list.classList.remove('collapsed');
            });
        }

        // ======================
        // PATH PANEL TOGGLE
        // ======================
        function togglePathPanel() {
            const panel = document.getElementById('path-panel');
            panel.classList.toggle('open');
        }

        // ======================
        // GIVE UP FUNCTIONALITY
        // ======================
        let globalGameController = null;

        function giveUp() {
            const confirmed = confirm(`Are you sure you want to give up?\n\nThis will show you the target page but won't count as a win.`);
            
            if (!confirmed) {
                return;
            }
            
            if (globalGameController) {
                globalGameController.stopTimer();
            }
            gameState.gaveUp = true;
            
            const timeInSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
            const mode = gameState.isDailyMode ? 'daily' : 'explore';
            stats.recordGame(false, gameState.totalClicks, timeInSeconds, gameState.path, mode, true);
            
            const modal = document.getElementById('win-modal');
            const modalContent = modal.querySelector('.modal-content');
            
            modalContent.innerHTML = `
                <h2>üè≥Ô∏è Challenge Ended</h2>
                <div class="win-stats">
                    <div class="stat-row">
                        <span class="stat-label">You were trying to reach:</span>
                        <span class="stat-value">${gameState.targetPage}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Clicks Used:</span>
                        <span class="stat-value">${gameState.totalClicks}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Time Spent:</span>
                        <span class="stat-value">${document.getElementById('timer').textContent}</span>
                    </div>
                </div>
                <div class="win-path">
                    <h3>üó∫Ô∏è Your Path So Far:</h3>
                    ${gameState.path.map((page, index) => `
                        <div class="path-item">
                            <div class="path-item-number">${index + 1}</div>
                            <div>${page}</div>
                        </div>
                    `).join('')}
                    <div style="text-align: center; margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; color: #856404;">
                        <strong>üí° Tip:</strong> Try exploring links related to broader categories or finding connections through related topics!
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary" onclick="retryGame()">üîÑ Try Again</button>
                    <button class="modal-btn secondary" onclick="startNewGame()">üéÆ New Challenge</button>
                </div>
            `;
            
            modal.classList.add('active');
        }

        // ======================
        // SEARCH FUNCTIONALITY (Ctrl+F)
        // ======================
        let searchOverlay = null;
        let searchInput = null;
        let searchResults = null;

        function initializeSearch() {
            searchOverlay = document.getElementById('search-overlay');
            searchInput = document.getElementById('search-input');
            searchResults = document.getElementById('search-results');
            
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                
                if (((e.ctrlKey || e.metaKey) && e.key === 'n') || (e.key === 'n' && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey)) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        return;
                    }
                    
                    e.preventDefault();
                    
                    if (!gameState.isDailyMode) {
                        handleNewGame();
                    } else {
                        showNotification('New Game shortcut is only available in Explore mode');
                    }
                }
                
                if (e.key === 'Escape' && searchOverlay.classList.contains('active')) {
                    closeSearch();
                }
                
                // 'H' for hint
                if (e.key === 'h' || e.key === 'H') {
                    console.log('H key pressed!');
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        console.log('Ignored - typing in input field');
                        return;
                    }
                    
                    const hintBtn = document.getElementById('hint-btn');
                    console.log('Hint button:', hintBtn);
                    console.log('Button disabled?', hintBtn?.disabled);
                    console.log('Game state:', {
                        currentPage: gameState.currentPage,
                        targetPage: gameState.targetPage,
                        hasWon: gameState.hasWon
                    });
                    
                    // Check if game is active by checking if we have current and target pages and haven't won yet
                    if (hintBtn && !hintBtn.disabled && gameState.currentPage && gameState.targetPage && !gameState.hasWon) {
                        console.log('Triggering hint!');
                        e.preventDefault();
                        hintBtn.click();
                    } else {
                        console.log('Hint conditions not met');
                    }
                }
            });
            
            searchOverlay.addEventListener('click', (e) => {
                if (e.target === searchOverlay) {
                    closeSearch();
                }
            });
            
            searchInput.addEventListener('input', performSearch);
        }

        function openSearch() {
            searchOverlay.classList.add('active');
            searchInput.value = '';
            searchResults.innerHTML = '';
            searchInput.focus();
        }

        function closeSearch() {
            searchOverlay.classList.remove('active');
        }

        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResults.innerHTML = '';
            
            if (query.length < 2) {
                return;
            }
            
            const gameArea = document.getElementById('game-area');
            const allLinks = gameArea.querySelectorAll('a');
            const allText = gameArea.querySelectorAll('p, li, h1, h2, h3, h4');
            
            let results = [];
            
            allLinks.forEach(link => {
                const text = link.textContent.toLowerCase();
                if (text.includes(query)) {
                    results.push({
                        type: 'link',
                        text: link.textContent,
                        element: link,
                        context: link.parentElement.textContent.substring(0, 150)
                    });
                }
            });
            
            allText.forEach(el => {
                const text = el.textContent.toLowerCase();
                if (text.includes(query) && !results.some(r => r.element === el)) {
                    const index = text.indexOf(query);
                    const start = Math.max(0, index - 50);
                    const end = Math.min(text.length, index + 100);
                    results.push({
                        type: 'text',
                        text: el.textContent.substring(start, end),
                        element: el
                    });
                }
            });
            
            results = results.slice(0, 20);
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">No results found</div>';
                return;
            }
            
            results.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'search-result-item';
                
                const highlightedText = result.text.replace(
                    new RegExp(`(${query})`, 'gi'),
                    '<strong>$1</strong>'
                );
                
                resultDiv.innerHTML = `
                    <div style="font-size: 0.9em; color: #667eea; margin-bottom: 5px;">
                        ${result.type === 'link' ? 'üîó Link' : 'üìÑ Text'}
                    </div>
                    <div>${highlightedText}...</div>
                `;
                
                resultDiv.addEventListener('click', () => {
                    result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    closeSearch();
                    
                    result.element.style.backgroundColor = '#ffeb3b';
                    setTimeout(() => {
                        result.element.style.backgroundColor = '';
                    }, 2000);
                });
                
                searchResults.appendChild(resultDiv);
            });
        }

        // ======================
        // INITIALIZE GAME
        // ======================
        const game = new GameController();
        globalGameController = game;
        game.initialize();
        initializeSearch();

        function startNewGame() {
            clearUrl();
            location.reload();
        }

        function retryGame() {
            if (!gameState.startPage || !gameState.targetPage) {
                return;
            }
            
            const modal = document.getElementById('win-modal');
            modal.classList.remove('active');
            
            const start = gameState.startPage;
            const target = gameState.targetPage;
            const difficulty = gameState.difficulty;
            
            gameState.currentPage = start;
            gameState.clickCount = 0;
            gameState.totalClicks = 0;
            gameState.visitedPages = new Set([start]);
            gameState.path = [start];
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.hasWon = false;
            gameState.gaveUp = false;
            gameState.difficulty = difficulty;
            
            updateUrl(
                start,
                target,
                start,
                0,
                0,
                [start],
                [start],
                gameState.startTime
            );
            
            location.reload();
        }
        
        // ======================
        // DEBUG MODE FUNCTIONS
        // ======================
        
        function toggleDebugMode() {
            const toggle = document.getElementById('debug-toggle');
            const panel = document.getElementById('debug-panel');
            const isActive = toggle.classList.toggle('active');
            panel.classList.toggle('active');
            
            localStorage.setItem('wikipath_debug_mode', isActive);
        }
        
        async function startDebugGame() {
            const startPage = document.getElementById('debug-start-page').value.trim();
            const targetPage = document.getElementById('debug-target-page').value.trim();
            const errorEl = document.getElementById('debug-game-error');
            
            errorEl.classList.remove('active');
            
            if (!startPage || !targetPage) {
                errorEl.textContent = '‚ùå Please enter both start and target pages';
                errorEl.classList.add('active');
                return;
            }
            
            if (startPage.toLowerCase() === targetPage.toLowerCase()) {
                errorEl.textContent = '‚ùå Start and target must be different';
                errorEl.classList.add('active');
                return;
            }
            
            const startValid = await validateWikipediaPage(startPage);
            const targetValid = await validateWikipediaPage(targetPage);
            
            if (!startValid) {
                errorEl.textContent = `‚ùå Start page "${startPage}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            if (!targetValid) {
                errorEl.textContent = `‚ùå Target page "${targetPage}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            const normalizedStart = startPage.replace(/ /g, '_');
            const normalizedTarget = targetPage.replace(/ /g, '_');
            
            gameState.isDailyMode = false;
            updateModeUI();
            
            window.location.href = `?start=${encodeURIComponent(normalizedStart)}&target=${encodeURIComponent(normalizedTarget)}`;
        }
        
        async function loadDebugPreview() {
            const pageName = document.getElementById('debug-preview-page').value.trim();
            const errorEl = document.getElementById('debug-preview-error');
            
            errorEl.classList.remove('active');
            
            if (!pageName) {
                errorEl.textContent = '‚ùå Please enter a page name';
                errorEl.classList.add('active');
                return;
            }
            
            const valid = await validateWikipediaPage(pageName);
            
            if (!valid) {
                errorEl.textContent = `‚ùå Page "${pageName}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            const normalizedPage = pageName.replace(/ /g, '_');
            gameState.currentPage = normalizedPage;
            
            try {
                const pageData = await fetchWikipediaPage(normalizedPage);
                globalGameController.renderPage(pageData);
                globalGameController.buildTableOfContents(pageData.sections || []);
                
                document.getElementById('game-area').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                errorEl.textContent = `‚ùå Error loading page: ${error.message}`;
                errorEl.classList.add('active');
            }
        }
        
        async function validateWikipediaPage(pageName) {
            try {
                const endpoint = 'https://en.wikipedia.org/w/api.php';
                const params = new URLSearchParams({
                    action: 'query',
                    titles: pageName,
                    format: 'json',
                    origin: '*'
                });
                
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                
                return pageId !== '-1';
            } catch (error) {
                console.error('Page validation error:', error);
                return false;
            }
        }
        
        function fillRandomPages() {
            const randomStart = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            let randomTarget;
            do {
                randomTarget = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            } while (randomTarget === randomStart);
            
            document.getElementById('debug-start-page').value = randomStart;
            document.getElementById('debug-target-page').value = randomTarget;
        }
        
        function fillRandomPreview() {
            const randomPage = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            document.getElementById('debug-preview-page').value = randomPage;
        }
        
        // ======================
        // WIKIPEDIA AUTOCOMPLETE
        // ======================
        
        let autocompleteTimeout = null;
        
        function setupAutocomplete(inputId, dropdownId) {
            const input = document.getElementById(inputId);
            const dropdown = document.getElementById(dropdownId);
            let selectedIndex = -1;
            
            input.addEventListener('input', async (e) => {
                const query = e.target.value.trim();
                
                clearTimeout(autocompleteTimeout);
                
                if (query.length < 2) {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                    return;
                }
                
                autocompleteTimeout = setTimeout(async () => {
                    const suggestions = await getWikipediaSuggestions(query);
                    
                    if (suggestions.length > 0) {
                        dropdown.innerHTML = '';
                        selectedIndex = -1;
                        
                        suggestions.forEach((suggestion, index) => {
                            const item = document.createElement('div');
                            item.className = 'debug-autocomplete-item';
                            item.textContent = suggestion;
                            
                            item.addEventListener('click', () => {
                                input.value = suggestion;
                                dropdown.classList.remove('active');
                                dropdown.innerHTML = '';
                            });
                            
                            dropdown.appendChild(item);
                        });
                        
                        dropdown.classList.add('active');
                    } else {
                        dropdown.classList.remove('active');
                        dropdown.innerHTML = '';
                    }
                }, 300);
            });
            
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.debug-autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items, selectedIndex);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items, selectedIndex);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                } else if (e.key === 'Escape') {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });
            
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });
        }
        
        function updateSelection(items, index) {
            items.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        async function getWikipediaSuggestions(query) {
            try {
                const endpoint = 'https://en.wikipedia.org/w/api.php';
                const params = new URLSearchParams({
                    action: 'opensearch',
                    search: query,
                    limit: 8,
                    namespace: 0,
                    format: 'json',
                    origin: '*'
                });
                
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                
                return data[1] || [];
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }

    </script>
</body>
</html>
