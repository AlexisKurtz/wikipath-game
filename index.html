<!DOCTYPE html>
<html lang="en">
<!--
    WikiPath - Wikipedia Navigation Game
    Version: 3.51.0
    Last Updated: 2025-12-22

    Changelog:
    - v3.51.0: Compact mobile header! Essential info only (target, moves, min, timer). Hides branding. Gets even smaller when scrolling down (50px ‚Üí 40px). Smooth transitions. Much more screen space for reading!
    - v3.50.4: Debug console toggle! Added floating üêõ button in bottom-left to show/hide debug console. Console now hidden by default. Click the bug to toggle!
    - v3.50.3: UX improvements! Toggle button positioned lower for better alignment. Entire H2 header is clickable again (not just the button). Resize fix still active - user toggles are never overridden!
    - v3.50.2: Mobile font size reduction! Reduced base font from 16px to 14px on mobile. All headings scaled down proportionally. Content padding reduced. More content fits on screen!
    - v3.50.1: REAL FIX! Found the actual bug - window resize events (from mobile Safari toolbar hiding) were re-collapsing sections. Now tracks user manual toggles and resize handler NEVER changes sections the user opened. BULLETPROOF!
    - v3.50.0: CORE FIX - Radical simplification! Removed ALL complex touch handling. ONLY the [+]/[-] button toggles sections (44x44px touch target). Headers are no longer clickable. Content can be scrolled freely without any interference. Simple, reliable, bulletproof.
    - v3.49.5: Stricter header tap detection! Headers now only toggle if there's ZERO movement (not even 1px). Added Clean & Copy buttons to debug console. Prevents sections from collapsing when scrolling near header area.
    - v3.49.4: Added on-screen debug console! Shows touch event logs in a floating panel. Comprehensive logging for header and wrapper touch events to debug collapsing issue.
    - v3.49.3: Fixed double-toggle bug! Headers now track last touch event time and ignore clicks within 500ms to prevent touch+click double-firing.
    - v3.49.2: Performance boost! Added CSS containment and content-visibility to section-content for faster rendering. Added performance logging to debug toggle delays.
    - v3.49.1: Touch control fixes! Removed 300ms tap delay with preventDefault. Increased movement tolerance (15px) to prevent false scroll detection. Headers now respond instantly to taps!
    - v3.49.0: iOS-quality touch controls! Fixed collapsible sections closing when scrolling content. Enhanced touch detection with movement tracking. Ripple effects on links. Active states for all touch targets. GPU acceleration. ARIA labels & keyboard support. 44x44pt touch targets. No double-tap zoom!
    - v3.48.0: Sticky fixes! Article h1 title stays visible when scrolling. Path panel header stays fixed. Desktop actions move left when panel opens. Action button text always visible!
    - v3.47.3: Final polish! Action buttons now have light grey background for contrast. All headings (h2, h3, h4) have scroll-margin-top for proper TOC alignment!
    - v3.47.2: Fixed all polish issues! Added text labels to Stats/Search buttons. Removed link hover backgrounds. TOC scroll now uses scroll-margin-top CSS for proper positioning!
    - v3.47.1: Polish fixes! üîß Action sidebar border for contrast. Link hover shows only underline (no grey box). TOC scrolls with proper offset for sticky header!
    - v3.47.0: Action button discoverability! üéØ Labels expand on hover with smooth animation. Primary actions always visible. Subtle pulse on first visit. Better UX!
    - v3.46.0: Design system! üé® CSS custom properties for colors, spacing (8px scale), border-radius, shadows, and font-weights. Consistent, maintainable, scalable design foundation!
    - v3.45.0: Accessibility improvements! ‚ôø Keyboard focus indicators (purple outline). Better color contrast (#666‚Üí#555). Reduced-motion support. ARIA labels for screen readers. WCAG AA compliant!
    - v3.44.0: Centered breadcrumb! Everything grows from middle. Smart collapse shows Start + Current + Target. Hover tooltip shows hidden steps!
    - v3.43.0: Perfect breadcrumb layout! üèÅ Start left-aligned. üéØ Target right-aligned. Middle centered. Flex arrows expand!
    - v3.42.0: Polish! üèÅ Start readable when current (dark blue). üéØ Target aligned right. Clean layout!
    - v3.41.0: Perfect breadcrumb! üéØ Target always on right. üí° Purple for hint steps. Orange for current backtrack. Better visibility!
    - v3.40.0: Smart breadcrumb! üèÅ Start always visible. Auto-collapses middle (8+ steps). üí° Hint indicator. Target always shown!
    - v3.39.0: Enhanced breadcrumb bar! üìç "You are here" flag centered on current page. üéØ Target page highlighted green. Auto-centers!
    - v3.38.0: Minimalistic path breadcrumb bar! Always visible under header on desktop. Auto-scrolls to latest. Backtracks highlighted.
    - v3.37.0: Action sidebar on right! Uses desktop space efficiently with fixed vertical bar. Tooltips on hover. Mobile keeps FAB.
    - v3.36.0: Revamped action buttons UX! Desktop: clean header buttons. Mobile: FAB menu. No more cluttered floating button on desktop!
    - v3.35.1: FIXED path tracking! Now correctly preserves all forward moves when backtracking (doesn't restore from URL during active game)
    - v3.35.0: Complete path tracking with visual distinction! Backtracks now appear with orange styling and ‚Ü©Ô∏è emoji
    - v3.34.0: Path now tracks all navigation including backtracks - shows complete journey in win screen
    - v3.33.0: FIXED BACK BUTTON! Use replaceState for redirects instead of pushState. Now back button works perfectly!
    - v3.32.3: Fixed back button! Initialize history state with replaceState on game load so there's something to go back to.
    - v3.32.2: Debug logging for history pushState to diagnose back button issue.
    - v3.32.1: Fixed browser back button! Now properly stores game state in history so back/forward navigation works correctly with cached pages.
    - v3.32.0: localStorage page caching! Visited pages are cached in browser for instant revisits. Max 50 pages, 1-hour expiry. Back/forward navigation is now instant!
    - v3.31.0: Skeleton screen loading! Shows animated placeholder layout while pages load for a polished, modern feel. Shimmer animation makes wait time feel faster.
    - v3.30.2: Code cleanup - removed debug console.log statements from External links removal.
    - v3.30.1: Removed "External links" from Table of Contents! Now filters it out so it doesn't appear in the TOC.
    - v3.30.0: External links section removal now works! Simplified logic to always remove "External links" sections since they're never useful for the game.
    - v3.29.3: Fixed External links removal! Now ignores navboxes/portal-bars/sister-bars when checking for Wikipedia links. These are just footer navigation, not actual content.
    - v3.29.2: Improved External links detection with console logging. Changed from exact match to includes() for better flexibility.
    - v3.29.1: Fixed External links removal to include the heading! Now removes the entire section including the "External links" heading itself.
    - v3.29.0: Remove "External links" sections! Cleans up end-of-article external link sections (unless they contain Wikipedia article links).
    - v3.28.4: Enhanced external content removal! Now removes ANY table/box with "External videos", "External media", "External links" headers, not just infoboxes.
    - v3.28.3: Improved external media infobox removal! Now properly detects and removes infoboxes with "Images"/"Video" headers that only contain YouTube/external identifiers with no substantive content.
    - v3.28.2: Smart removal of external media infoboxes! Removes entire infoboxes that only contain external links/videos, or just removes external media rows from larger infoboxes.
    - v3.28.1: Removed external videos/media boxes for cleaner article layout.
    - v3.28.0: Added loading state on clicked links! Links now show a subtle spinner and reduced opacity while the page loads. Immediate click feedback for better UX.
    - v3.27.2: Perfect progress bar! Fixed to exactly 3px with !important flags. Removed header border. Ultra-clean single loading indicator.
    - v3.27.1: Refined progress bar! Ultra-minimal 2px height, smoother animations, subtle glow. Hidden loading spinner. Clean, modern look following UX best practices.
    - v3.27.0: Added sleek top progress bar! YouTube/GitHub-style loading indicator at the top of screen. Smooth animations, gradient blue color, auto-hides when complete. Visual feedback for every page load!
    - v3.26.0: PERFORMANCE BOOST! Implemented hover prefetch - pages load INSTANTLY when clicked (200ms hover triggers background fetch). Smart cache system with max 10 pages, max 3 concurrent prefetches. Clicks now feel instant!
    - v3.25.0: MAJOR typography upgrade! Modern sans-serif font stack (16px base). Enhanced heading hierarchy with better sizing (h2: 1.75em, h3: 1.35em). Improved vertical rhythm with 1.2em paragraph spacing. Added letter-spacing, muted caption colors, and refined blockquotes.
    - v3.24.0: EXACT Wikipedia layout match! Fixed image box sizing to wrap tightly around images (display: table). Added .mw-default-size support (220px max). Removed excessive borders. Images now align perfectly with paragraphs matching native Wikipedia.
    - v3.23.0: Fixed Wikipedia layout! H2 sections now clear floats (start after infobox). Figure elements default to right-aligned like Wikipedia. Content flows properly matching native Wikipedia layout.
    - v3.22.0: Improved image captions! Added comprehensive CSS for Wikipedia's caption structures (.thumb, .thumbcaption, figure, figcaption, gallery). Captions now display properly with borders, backgrounds, and mobile responsiveness matching native Wikipedia.
    - v3.21.0: ACTUALLY FIXED IMAGES! Non-article links (File:) were being removed along with their images. Now unwraps images from links to preserve them.
    - v3.20.0: FIXED IMAGES! Was removing 58/60 images by accident. Now only removes notification boxes that don't contain images
    - v3.19.0: Fixed link wobble on hover (removed padding/margin changes) + added image debugging to diagnose loading issues
    - v3.18.0: Made links bolder (font-weight: 600) + improved image loading (srcset support, better error handling, lazy loading)
    - v3.17.0: Fixed hint scrolling (expands collapsed sections) + fixed mobile touch scrolling (detects tap vs scroll gesture)
    - v3.16.0: FOUND IT! H2s are wrapped in mw-heading divs. Now looking at siblings of the wrapper, not the H2 itself!
    - v3.15.0: Simplified approach - walks DOM siblings directly instead of trying to map positions (should FINALLY work!)
    - v3.14.0: THE ACTUAL FIX! Was looking at wrong DOM level - now looks inside .wikipedia-article wrapper where content actually is
    - v3.13.0: COMPLETELY REWROTE collapsible algorithm - finds content by array position, not DOM siblings (should actually work now!)
    - v3.12.1: Added extensive DOM structure debugging to diagnose why content isn't being found
    - v3.12.0: ACTUALLY FIXED! Made sections RESPONSIVE - collapse/expand based on current window width, not just page load
    - v3.11.3: Added mobile detection alert for debugging WTF is happening
    - v3.11.2: FIXED collapsible sections! Rewrote algorithm to handle Wikipedia's nested HTML structure properly
    - v3.11.1: Added extensive debugging for collapsible sections to diagnose issues
    - v3.11.0: Added collapsible sections (collapsed by default on mobile + special sections like "Royal Titulary"), hidden TOC on mobile
    - v3.10.2: Added keyboard shortcut labels to menu items (H for Hint, R for Retry, Ctrl+F for Search)
    - v3.10.1: CRITICAL FIX! Hints now use cached optimal path instead of recalculating (fixes non-optimal hints)
    - v3.10.0: Added Retry feature with 'R' keyboard shortcut to restart current game
    - v3.9.9: CRITICAL FIX! Fixed bidirectional BFS path reconstruction (reverse THEN slice)
    - v3.9.8: FIXED hint bug! Removed title normalization, let Wikipedia API handle it correctly
    - v3.9.7: Added extensive debugging for hint bug (title normalization issues)
    - v3.9.6: Fixed "URI malformed" error with try-catch on decodeURIComponent
    - v3.9.5: Added extensive debugging + safety check for hint bug (suggesting current page)
    - v3.9.4: Fixed hint highlighting selector (#game-area not #content) + added debugging
    - v3.9.3: Fixed hint keyboard shortcut and gold highlight (now working!)
    - v3.9.2: Added 'H' keyboard shortcut for hints + visual gold highlight of suggested link
    - v3.9.1: Removed non-clickable links from page (cleaner UX)
    - v3.9.0: Added minimum clicks solver, hints, and optimal path comparison
    - v3.8.4: Fixed redirect bug - now detects win when clicking redirect links
    [previous changelog entries...]
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiPath - Connect the Pages</title>
    <style>
        /* Design System: CSS Custom Properties */
        :root {
            /* Color System */
            --color-primary: #0645ad;
            --color-primary-hover: #0b0080;
            --color-primary-light: #1976d2;

            --color-success: #28a745;
            --color-success-light: #4caf50;
            --color-warning: #ff9800;
            --color-danger: #c62828;
            --color-danger-light: #f44336;
            --color-accent: #9c27b0;
            --color-accent-dark: #6a1b9a;

            --color-text-primary: #202122;
            --color-text-secondary: #555;
            --color-text-tertiary: #777;

            --color-bg-primary: #ffffff;
            --color-bg-secondary: #f8f9fa;
            --color-bg-tertiary: #f0f0f0;

            --color-border: #e0e0e0;
            --color-border-light: #f0f0f0;

            /* Spacing Scale (8px base unit) */
            --space-1: 8px;
            --space-2: 16px;
            --space-3: 24px;
            --space-4: 32px;
            --space-5: 40px;
            --space-6: 48px;

            /* Border Radius Scale */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            --radius-full: 50%;

            /* Shadow System */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 8px 20px rgba(0, 0, 0, 0.15);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.4);

            /* Font Weight Scale */
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;

            /* Typography */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Optimize scrolling performance */
        html {
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: var(--font-family);
            background: var(--color-bg-secondary);
            min-height: 100vh;
            overscroll-behavior-y: none; /* Prevent pull-to-refresh on iOS */
        }

        /* Accessibility: Keyboard Focus Indicators */
        a:focus,
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        [tabindex]:focus {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
        }

        /* Skip focus outline for mouse users */
        a:focus:not(:focus-visible),
        button:focus:not(:focus-visible),
        input:focus:not(:focus-visible),
        select:focus:not(:focus-visible),
        textarea:focus:not(:focus-visible),
        [tabindex]:focus:not(:focus-visible) {
            outline: none;
        }

        /* Enhanced focus for keyboard users */
        a:focus-visible,
        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible,
        [tabindex]:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
        }

        /* Top Progress Bar - Ultra-Minimal */
        .top-progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px !important;
            max-height: 3px !important;
            min-height: 3px !important;
            background: #2196f3;
            z-index: 10000;
            transition: width 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            opacity: 0;
            box-sizing: border-box;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            overflow: hidden;
        }

        .top-progress-bar.loading {
            opacity: 1;
        }

        .top-progress-bar.complete {
            width: 100% !important;
            opacity: 0;
            transition: width 0.15s ease, opacity 0.4s ease 0.15s;
        }

        /* Compact Header */
        .game-header {
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            padding: var(--space-2) var(--space-3);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            gap: var(--space-3);
        }

        /* Left Side - Branding & Stats */
        .header-left {
            display: flex;
            align-items: center;
            gap: 25px;
        }

        .game-branding {
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
        }

        .game-branding h1 {
            font-size: 1.4em;
            color: #0645ad;
            font-weight: 600;
        }

        .game-branding .logo {
            font-size: 1.8em;
        }

        .header-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-item-compact {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .stat-label-compact {
            font-size: 0.65em;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-value-compact {
            font-size: 1em;
            font-weight: 700;
            color: #0645ad;
        }

        /* NEW: Minimum clicks styling */
        .stat-value-compact.minimum {
            color: #28a745;
        }

        .stat-value-compact.loading {
            color: #777;
            font-size: 0.8em;
        }

        /* Center - Target Page (Prominent) */
        .header-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .target-display {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 2px solid #0645ad;
            border-radius: 12px;
            padding: 12px 24px;
            text-align: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(6, 69, 173, 0.15);
        }

        .target-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(6, 69, 173, 0.25);
            border-color: #0b0080;
        }

        .target-label {
            font-size: 0.7em;
            color: #0645ad;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        #target-page-display {
            font-size: 1.3em;
            line-height: 1.3;
            color: #0b0080;
            font-weight: 700;
        }

        /* Right Side - Mode Switch */
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Compact Mode Switch */
        .mode-switch-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .mode-switch-label {
            font-size: 0.65em;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .mode-switch {
            display: flex;
            background: #e0e0e0;
            border-radius: 20px;
            padding: 3px;
            gap: 3px;
            position: relative;
        }

        .mode-switch-btn {
            background: transparent;
            border: none;
            color: #555;
            padding: 6px 14px;
            border-radius: 17px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 600;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .mode-switch-btn:hover {
            color: #333;
        }

        .mode-switch-btn.active {
            background: white;
            color: #0645ad;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Old Mode Toggle - Remove */
        .mode-toggle {
            display: none;
        }

        /* Old Stats Bar - Remove */
        .stats-bar {
            display: none;
        }

        .stat-item {
            display: none;
        }

        .stat-item.target {
            display: none;
        }

        /* Difficulty Badge */
        .difficulty-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.65em;
            font-weight: 700;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .difficulty-easy {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1.5px solid #4caf50;
        }

        .difficulty-medium {
            background: #fff3e0;
            color: #e65100;
            border: 1.5px solid #ff9800;
        }

        .difficulty-hard {
            background: #ffebee;
            color: #c62828;
            border: 1.5px solid #f44336;
        }

        .difficulty-expert {
            background: #f3e5f5;
            color: #6a1b9a;
            border: 1.5px solid #9c27b0;
        }

        /* Target Tooltip */
        .target-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px;
            background: white;
            color: #333;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 300px;
            max-width: 400px;
            text-align: left;
        }

        .target-display:hover .target-tooltip {
            display: block;
        }

        .target-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid white;
        }

        .target-tooltip h4 {
            margin-bottom: 8px;
            color: #0645ad;
            font-size: 1em;
        }

        .target-tooltip p {
            font-size: 0.9em;
            line-height: 1.5;
            color: #555;
        }

        /* Settings Menu */
        .settings-menu {
            position: relative;
        }

        .settings-btn {
            background: #f0f0f0;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: #e0e0e0;
        }

        /* Collapsible Path Panel */
        .path-panel {
            position: fixed;
            right: -350px;
            top: 0;
            width: 350px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            z-index: 200;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .path-panel.open {
            right: 0;
        }

        .path-panel-header {
            background: #0645ad;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            height: 60px;
            flex-shrink: 0;
        }

        .path-panel-header h3 {
            font-size: 1.1em;
        }

        .path-panel-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .path-panel-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .path-panel-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .path-timeline {
            position: relative;
            padding-left: 30px;
        }

        .path-timeline::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #e0e0e0;
        }

        .path-timeline-item {
            position: relative;
            margin-bottom: 20px;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #0645ad;
        }

        .path-timeline-item.current {
            background: #e3f2fd;
            border-left-color: #1976d2;
            border-left-width: 4px;
        }

        .path-timeline-item::before {
            content: '';
            position: absolute;
            left: -34px;
            top: 15px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #0645ad;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #e0e0e0;
        }

        .path-timeline-item.current::before {
            background: #1976d2;
            width: 16px;
            height: 16px;
            left: -36px;
            top: 13px;
        }

        .path-item-number {
            font-size: 0.75em;
            color: #555;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .path-item-title {
            font-size: 0.95em;
            color: #202122;
            font-weight: 500;
        }

        /* Desktop Action Sidebar - Right Side */
        .desktop-actions {
            position: fixed;
            right: 24px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
            z-index: 100;
            background: var(--color-bg-primary);
            padding: var(--space-2);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--color-border);
            transition: right 0.3s ease, transform 0.3s ease;
        }

        /* Move desktop actions left when path panel is open */
        .desktop-actions.panel-open {
            right: 370px !important; /* 350px panel width + 20px spacing */
        }

        /* Subtle pulse animation to draw attention on first load */
        @keyframes sidebar-hint {
            0%, 100% {
                box-shadow: var(--shadow-lg);
            }
            50% {
                box-shadow: 0 8px 24px rgba(6, 69, 173, 0.25);
            }
        }

        .desktop-actions.first-load {
            animation: sidebar-hint 2s ease-in-out 3;
        }

        .action-btn {
            padding: var(--space-2);
            border: none;
            background: var(--color-bg-secondary);
            border-radius: var(--radius-lg);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: var(--font-weight-medium);
            color: var(--color-text-primary);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: var(--space-1);
            white-space: nowrap;
            position: relative;
            min-width: 44px;
            min-height: 44px;
            overflow: hidden;
        }

        .action-btn:hover {
            background: var(--color-bg-tertiary);
            transform: translateX(-4px);
            box-shadow: var(--shadow-sm);
        }

        .action-btn:active {
            transform: translateX(-2px) scale(0.98);
        }

        .action-btn.primary {
            background: var(--color-primary);
            color: white;
        }

        .action-btn.primary:hover {
            background: var(--color-primary-hover);
        }

        .action-btn.danger {
            color: var(--color-danger);
        }

        .action-btn.danger:hover {
            background: #ffebee;
            color: var(--color-danger-light);
        }

        .action-btn .emoji {
            font-size: 1.4em;
            flex-shrink: 0;
        }

        /* Show text labels on hover - expand button width */
        .action-btn span:not(.emoji) {
            max-width: 120px;
            opacity: 1;
            transition: max-width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
            overflow: hidden;
            color: var(--color-text-primary);
        }

        .action-btn:hover span:not(.emoji) {
            max-width: 120px;
            opacity: 1;
        }

        /* Optional: Always show text for primary actions */
        .action-btn.primary span:not(.emoji) {
            max-width: 120px;
            opacity: 1;
            color: white;
        }

        /* Danger button text color */
        .action-btn.danger span:not(.emoji) {
            color: var(--color-danger);
        }

        /* Tooltips removed - labels now show inline on hover */

        /* Divider between action groups */
        .action-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }

        /* Text labels are now shown on hover via max-width animation above */

        /* Minimalistic Path Bar under header */
        .path-bar {
            background: linear-gradient(to bottom, #f8f9fa, #ffffff);
            border-bottom: 1px solid #e0e0e0;
            padding: 8px 20px 28px 20px;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            scrollbar-width: thin;
            scrollbar-color: #ccc transparent;
            position: relative;
            scroll-behavior: smooth;
        }

        .path-bar::-webkit-scrollbar {
            height: 4px;
        }

        .path-bar::-webkit-scrollbar-track {
            background: transparent;
        }

        .path-bar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 2px;
        }

        .path-bar::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .path-breadcrumb {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.85em;
            width: 100%;
            flex-wrap: nowrap;
        }

        .path-step {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: white;
            border-radius: 6px;
            color: #555;
            border: 1px solid #e0e0e0;
            transition: all 0.2s;
            position: relative;
        }

        .path-step.current {
            background: #0645ad;
            color: white;
            border-color: #0645ad;
            font-weight: 600;
        }

        .path-step.current::after {
            content: 'üìç You are here';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #0645ad;
            font-weight: 600;
            white-space: nowrap;
            animation: fadeInFlag 0.3s ease;
        }

        /* Current page that is a backtrack - stronger colors for visibility */
        .path-step.current.backtrack {
            background: #ff6f00;
            color: white;
            border-color: #ff6f00;
            opacity: 1;
        }

        .path-step.current.backtrack::after {
            color: #ff6f00;
        }

        @keyframes fadeInFlag {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .path-step.target {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
            font-weight: 600;
        }

        .path-step.target::before {
            content: 'üéØ ';
        }

        /* Target indicator at the end - always shown */
        .path-step.target-indicator {
            background: #e8f5e9;
            color: #2e7d32;
            border-color: #4caf50;
            font-weight: 600;
            border-width: 2px;
        }

        .path-step.target-indicator::before {
            content: 'üéØ ';
        }

        .path-step.backtrack {
            background: #fff3e0;
            border-color: #ff9800;
            opacity: 0.8;
        }

        .path-step .step-number {
            font-size: 0.75em;
            opacity: 0.7;
        }

        .path-step.start {
            background: #e3f2fd;
            border-color: #2196f3;
            font-weight: 600;
        }

        .path-step.start::before {
            content: 'üèÅ ';
        }

        /* Start page when current - better visibility */
        .path-step.start.current {
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .path-step.start.current::after {
            color: #1976d2;
        }

        /* Hint-assisted step - purple/violet color scheme */
        .path-step.hint-used {
            background: #f3e5f5;
            border-color: #9c27b0;
            color: #6a1b9a;
            position: relative;
        }

        .path-step.hint-used::before {
            content: 'üí° ';
        }

        .path-step.hint-used.current {
            background: #9c27b0;
            color: white;
            border-color: #9c27b0;
        }

        .path-step.hint-used.current::after {
            color: #9c27b0;
        }

        .path-arrow {
            color: #ccc;
            font-size: 0.9em;
        }

        .path-arrow-flex {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ccc;
            font-size: 0.9em;
            min-width: 20px;
        }

        .path-collapse {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            background: #f5f5f5;
            border-radius: 6px;
            color: #777;
            border: 1px dashed #ccc;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .path-collapse:hover {
            background: #ebebeb;
            color: #555;
        }

        .path-collapse-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 0.9em;
            white-space: normal;
            margin-top: 8px;
            z-index: 1000;
            max-width: 90vw;
            min-width: 300px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .path-collapse:hover .path-collapse-tooltip {
            display: block;
        }

        .path-collapse-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.9);
        }

        /* Floating Action Menu - Mobile Only */
        .fab-menu {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 150;
            display: none; /* Hidden on desktop */
        }

        .fab-menu-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #0645ad;
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(6, 69, 173, 0.4);
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .fab-menu-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(6, 69, 173, 0.5);
        }

        .fab-menu-button.active {
            background: #0b0080;
        }

        .fab-menu-items {
            position: absolute;
            bottom: 75px;
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            padding: 8px;
            min-width: 200px;
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 151;
        }

        .fab-menu.open .fab-menu-items {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .fab-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            cursor: pointer;
            border-radius: 8px;
            font-size: 0.95em;
            color: #333;
            transition: background 0.2s;
            font-weight: 500;
            user-select: none;
            position: relative;
        }

        .fab-menu-item .keyboard-shortcut {
            margin-left: auto;
            font-size: 0.75em;
            padding: 2px 6px;
            background: #e0e0e0;
            border-radius: 3px;
            color: #555;
            font-family: monospace;
            font-weight: 600;
        }

        .fab-menu-item:hover {
            background: #f0f0f0;
        }

        .fab-menu-item.danger:hover {
            background: #ffebee;
            color: #c62828;
        }

        .fab-menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .fab-menu-item .emoji {
            font-size: 1.3em;
            width: 24px;
            text-align: center;
        }

        .fab-menu-divider {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }

        /* Container with TOC */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            min-height: calc(100vh - 80px);
            display: flex;
            position: relative;
        }

        /* Table of Contents (KEPT) */
        .toc-container {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            position: sticky;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .toc-title {
            font-weight: 700;
            font-size: 1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0645ad;
            color: #202122;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toc-collapse-controls {
            display: flex;
            gap: 5px;
        }

        .toc-collapse-btn {
            background: transparent;
            border: 1px solid #0645ad;
            color: #0645ad;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 700;
            line-height: 1;
            min-width: 28px;
        }

        .toc-collapse-btn:hover {
            background: #0645ad;
            color: white;
        }

        .toc-list {
            list-style: none;
        }

        .toc-item {
            margin-bottom: 4px;
        }

        .toc-section-header {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 5px 0;
            font-weight: 600;
            color: #202122;
            font-size: 0.9em;
        }

        .toc-section-header:hover {
            color: #0645ad;
        }

        .toc-collapse-icon {
            font-size: 0.7em;
            transition: transform 0.2s;
        }

        .toc-section-header.collapsed .toc-collapse-icon {
            transform: rotate(-90deg);
        }

        .toc-section-header.no-children {
            cursor: pointer;
            padding-left: 0;
        }

        .toc-subsections {
            list-style: none;
            margin-left: 15px;
            margin-top: 4px;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .toc-subsections.collapsed {
            max-height: 0;
        }

        .toc-link {
            color: #0645ad;
            text-decoration: none;
            font-size: 0.9em;
            display: block;
            padding: 5px 0;
            cursor: pointer;
            line-height: 1.4;
            transition: color 0.2s;
        }

        .toc-link:hover {
            color: #0b0080;
            text-decoration: underline;
        }

        .toc-link.active {
            font-weight: 700;
            color: #0b0080;
        }

        /* Main content area */
        .content-area {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
        }

        .wikipedia-article {
            /* Modern, readable font stack - falls back gracefully */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            font-size: 16px; /* Optimal for reading (16-18px is ideal) */
            line-height: 1.7; /* Increased for better readability */
            color: #202122;
            max-width: 900px;
            letter-spacing: 0.01em; /* Subtle spacing improves readability */
        }

        .wikipedia-article h1 {
            font-size: 2.5em; /* Slightly smaller for better proportion */
            margin-bottom: 0.5em;
            margin-top: 0;
            padding-top: 0.25em;
            padding-bottom: 0.3em;
            border-bottom: 1px solid #a2a9b1;
            font-weight: 600; /* Slightly bolder for clarity */
            line-height: 1.25;
            color: #202122;
            letter-spacing: -0.02em; /* Tighter spacing for large text */
            position: sticky;
            top: 0; /* Sticky within the content-area scroll container */
            background: white;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .wikipedia-article h2 {
            font-size: 1.75em; /* Increased for better hierarchy */
            margin-top: 1.5em; /* More breathing room */
            margin-bottom: 0.75em;
            padding-bottom: 0.3em;
            border-bottom: 1px solid #a2a9b1;
            font-weight: 600;
            line-height: 1.3;
            color: #202122;
            letter-spacing: -0.01em;
            scroll-margin-top: 220px; /* Account for sticky header (80px) + sticky h1 title (~140px) */
        }

        /* Ensure h2 sections clear floated elements (especially the infobox) */
        .wikipedia-article .mw-heading h2 {
            clear: both;
        }

        .wikipedia-article h3 {
            font-size: 1.35em; /* Increased for better distinction */
            margin-top: 1.25em;
            margin-bottom: 0.6em;
            font-weight: 600;
            line-height: 1.35;
            color: #202122;
            scroll-margin-top: 150px; /* Account for sticky header + breadcrumb */
        }

        .wikipedia-article h4 {
            font-size: 1.15em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.4;
            color: #202122;
            scroll-margin-top: 150px; /* Account for sticky header + breadcrumb */
        }

        .wikipedia-article p {
            margin-bottom: 1.2em; /* Increased spacing between paragraphs */
            line-height: 1.7;
        }

        .wikipedia-article a {
            color: #0645ad;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            border-bottom: 1px solid transparent;
            position: relative;
        }

        .wikipedia-article a:hover {
            color: var(--color-primary-hover);
            border-bottom: 1px solid var(--color-primary);
        }

        .wikipedia-article a.visited-link {
            color: #7c3aed;
            opacity: 0.85;
        }

        .wikipedia-article a.visited-link:hover {
            color: #6d28d9;
            border-bottom-color: #7c3aed;
        }

        .wikipedia-article a.disambiguation-link {
            color: var(--color-danger);
            font-style: italic;
            font-weight: var(--font-weight-semibold);
        }

        .wikipedia-article a.disambiguation-link:hover {
            color: #991b1b;
            border-bottom-color: var(--color-danger);
        }

        /* Touch active state */
        .touch-active {
            background: rgba(6, 69, 173, 0.08) !important;
            border-radius: 3px;
        }

        /* Ripple effect for touch feedback */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            transform: scale(0);
            animation: rippleEffect 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        /* Link Preview Tooltip */
        .link-preview {
            display: none;
            position: fixed;
            background: white;
            border: 2px solid #0645ad;
            border-radius: 8px;
            padding: 12px 16px;
            max-width: 350px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 10000;
            pointer-events: none;
        }

        .link-preview.active {
            display: block;
        }

        .link-preview-title {
            font-weight: 700;
            color: #0645ad;
            margin-bottom: 6px;
            font-size: 1.05em;
        }

        .link-preview-text {
            color: #333;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .link-preview-loading {
            color: #555;
            font-style: italic;
            font-size: 0.85em;
        }

        .wikipedia-article ul, .wikipedia-article ol {
            margin-left: 1.8em;
            margin-bottom: 1.2em;
            line-height: 1.7;
        }

        .wikipedia-article li {
            margin-bottom: 0.5em;
        }

        .wikipedia-article blockquote {
            margin: 1.5em 2em;
            padding-left: 1.5em;
            border-left: 3px solid #0645ad;
            color: #404040;
            font-style: italic;
            line-height: 1.7;
        }

        .wikipedia-article blockquote p {
            margin-bottom: 0.8em;
        }

        .wikipedia-article img {
            max-width: 100%;
            height: auto;
        }

        /* Infobox positioning - float to the right like Wikipedia */
        .wikipedia-article .infobox {
            float: right;
            clear: right;
            width: 300px;
            margin: 0 0 1.5em 1.5em;
            padding: 0.75em;
            background: #f8f9fa;
            border: 1px solid #a2a9b1;
            font-size: 0.875em; /* Proportional to new base size */
            line-height: 1.5;
        }

        .wikipedia-article .infobox-image {
            text-align: center;
            margin-bottom: 0.5em;
        }

        .wikipedia-article .infobox img {
            width: 100%;
            height: auto;
        }

        .wikipedia-article .infobox th,
        .wikipedia-article .infobox td {
            padding: 0.3em 0.5em;
            vertical-align: top;
        }

        .wikipedia-article .infobox th {
            text-align: left;
            font-weight: 600;
            background: #eaecf0;
        }

        .wikipedia-article .infobox caption {
            font-weight: bold;
            font-size: 1.1em;
            padding: 0.5em;
            background: #eaecf0;
        }

        /* Wikipedia Thumbnail Images with Captions */
        .wikipedia-article .thumb {
            margin: 0.5em 0 1.3em 1.4em;
            background-color: #f8f9fa;
            border: 1px solid #c8ccd1;
            padding: 3px;
            font-size: 94%;
            text-align: center;
            overflow: hidden;
            display: inline-block;
            box-sizing: content-box;
        }

        .wikipedia-article .thumb.tright {
            clear: right;
            float: right;
            margin: 0.5em 0 1.3em 1.4em;
        }

        .wikipedia-article .thumb.tleft {
            clear: left;
            float: left;
            margin: 0.5em 1.4em 1.3em 0;
        }

        .wikipedia-article .thumbinner {
            padding: 3px;
            background-color: #f8f9fa;
            font-size: 94%;
            text-align: center;
            overflow: hidden;
            min-width: 100px;
        }

        .wikipedia-article .thumbimage {
            border: none;
            background-color: #fff;
            display: block;
        }

        .wikipedia-article .thumbcaption {
            border: none;
            text-align: left;
            line-height: 1.5;
            padding: 6px;
            font-size: 0.875em; /* 14.875px based on 17px base */
            color: #54595d; /* Slightly muted for captions */
        }

        .wikipedia-article .magnify {
            display: none; /* Hide magnifying glass icon */
        }

        /* Figure and Figcaption (Semantic HTML) */
        .wikipedia-article figure {
            margin: 0.5em 0 1.3em 1.4em;
            padding: 3px;
            background-color: #f8f9fa;
            border: 1px solid #c8ccd1;
            max-width: 100%;
            float: right; /* Default to right like Wikipedia */
            clear: right;
            display: table; /* Makes figure wrap tightly around content */
            box-sizing: content-box;
        }

        /* Wikipedia's default size for figures */
        .wikipedia-article figure.mw-default-size {
            max-width: 220px; /* Wikipedia's default thumbnail width */
        }

        .wikipedia-article figure.mw-halign-right {
            clear: right;
            float: right;
            margin: 0.5em 0 1.3em 1.4em;
        }

        .wikipedia-article figure.mw-halign-left {
            clear: left;
            float: left;
            margin: 0.5em 1.4em 1.3em 0;
        }

        .wikipedia-article figure.mw-halign-center {
            margin: 0.5em auto;
            display: table;
            float: none;
            clear: both;
        }

        .wikipedia-article figure > a {
            display: block;
        }

        .wikipedia-article figure img {
            display: block;
            height: auto;
        }

        .wikipedia-article figcaption {
            font-size: 0.875em; /* 14.875px based on 17px base */
            line-height: 1.5;
            padding: 6px;
            color: #54595d; /* Slightly muted for captions */
            text-align: left;
            display: table-caption;
            caption-side: bottom;
        }

        /* Gallery Images */
        .wikipedia-article .gallery {
            margin: 2px;
            padding: 2px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .wikipedia-article .gallerybox {
            margin: 2px;
            padding: 5px;
            display: inline-block;
            vertical-align: top;
            background-color: #f8f9fa;
            border: 1px solid #c8ccd1;
            text-align: center;
        }

        .wikipedia-article .gallerybox .thumb {
            margin: 2px auto;
            border: none;
            background: transparent;
            padding: 0;
        }

        .wikipedia-article .gallerytext,
        .wikipedia-article .gallerytxt {
            font-size: 0.85em;
            line-height: 1.4em;
            padding: 2px 4px;
            color: #202122;
            text-align: center;
        }

        /* Make sure content flows around infobox */
        .wikipedia-article p {
            margin-bottom: 0.8em;
            clear: none;
        }

        /* Hide full disclaimer boxes, show compact version */
        .wikipedia-article .ambox,
        .wikipedia-article .hatnote,
        .wikipedia-article .dablink {
            display: none !important;
        }

        /* Hide edit buttons */
        .wikipedia-article .mw-editsection,
        .wikipedia-article [class*="editsection"] {
            display: none !important;
        }

        /* Starting Page Indicator */
        .starting-page-indicator {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }

        .starting-page-indicator .icon {
            font-size: 1.5em;
        }

        .starting-page-indicator .text {
            flex: 1;
        }

        .starting-page-indicator .label {
            font-weight: 700;
            color: #2e7d32;
            font-size: 0.9em;
            margin-bottom: 2px;
        }

        .starting-page-indicator .description {
            font-size: 0.85em;
            color: #1b5e20;
        }

        /* Article Notice Icons - Top Right Corner */
        .article-notices-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            z-index: 10;
        }

        .article-notice {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 5px 7px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: help;
            position: relative;
            min-width: 28px;
            height: 28px;
        }

        .article-notice.verification {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }

        .article-notice.cleanup {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .article-notice.recent-changes {
            background: #e3f2fd;
            color: #0d47a1;
            border: 1px solid #2196f3;
        }

        .article-notice.recent-death {
            background: #f3e5f5;
            color: #4a148c;
            border: 1px solid #9c27b0;
        }

        .article-notice:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            padding: 8px 12px;
            background: #333;
            color: white;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Make article title area have relative positioning for notices */
        .wikipedia-article {
            position: relative;
        }

        /* ======================
           DEBUG MODE (LITE)
           ====================== */
        
        .debug-toggle {
            display: none; /* Hidden by default - controlled by JS */
            background: #ff9800;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: background 0.2s;
        }

        .debug-toggle:hover {
            background: #f57c00;
        }

        .debug-toggle.active {
            background: #4caf50;
        }

        .debug-panel {
            display: none;
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
        }

        .debug-panel.active {
            display: block;
        }

        .debug-panel h3 {
            margin: 0 0 15px 0;
            color: #e65100;
            font-size: 1.1em;
        }

        .debug-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .debug-section:last-child {
            margin-bottom: 0;
        }

        .debug-section h4 {
            margin: 0 0 10px 0;
            color: #f57c00;
            font-size: 0.95em;
        }

        .debug-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .debug-input:focus {
            outline: none;
            border-color: #ff9800;
        }

        .debug-button {
            background: #ff9800;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            margin-right: 8px;
            transition: background 0.2s;
        }

        .debug-button:hover {
            background: #f57c00;
        }

        .debug-button.secondary {
            background: #757575;
        }

        .debug-button.secondary:hover {
            background: #616161;
        }

        .debug-error {
            color: #d32f2f;
            font-size: 0.85em;
            margin-top: 5px;
            display: none;
        }

        .debug-error.active {
            display: block;
        }

        .debug-autocomplete {
            position: absolute;
            background: white;
            border: 2px solid #ff9800;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .debug-autocomplete.active {
            display: block;
        }

        .debug-autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.9em;
        }

        .debug-autocomplete-item:last-child {
            border-bottom: none;
        }

        .debug-autocomplete-item:hover {
            background: #fff3e0;
        }

        .debug-autocomplete-item.selected {
            background: #ffe0b2;
        }

        .debug-input-wrapper {
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            font-size: 0.9em;
            color: #777;
            opacity: 0.5;
        }

        .loading::before {
            content: '';
            display: none; /* Hide spinner - we have progress bar now */
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0645ad;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Page Transition Animation */
        .wikipedia-article {
            animation: fadeIn 0.4s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Click Animation Feedback */
        @keyframes clickPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.95);
            }
            100% {
                transform: scale(1);
            }
        }

        .click-feedback {
            animation: clickPulse 0.2s ease;
        }

        /* Loading State for Clicked Links */
        .wikipedia-article a.loading {
            opacity: 0.6;
            pointer-events: none;
            padding-right: 20px;
        }

        .wikipedia-article a.loading::after {
            content: '';
            position: absolute;
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid #0645ad;
            border-top-color: transparent;
            border-radius: 50%;
            animation: linkSpinner 0.6s linear infinite;
        }

        @keyframes linkSpinner {
            to {
                transform: translateY(-50%) rotate(360deg);
            }
        }

        /* Confetti Animation */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #0645ad;
            position: absolute;
            animation: confettiFall 3s linear forwards;
            z-index: 9999;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        /* Skeleton Screen Loading */
        .skeleton-container {
            max-width: 900px;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }
            100% {
                background-position: -200% 0;
            }
        }

        .skeleton-title {
            height: 40px;
            width: 60%;
            margin-bottom: 20px;
        }

        .skeleton-infobox {
            float: right;
            width: 300px;
            height: 400px;
            margin: 0 0 20px 20px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
        }

        .skeleton-paragraph {
            height: 16px;
            margin-bottom: 12px;
        }

        .skeleton-paragraph.short {
            width: 70%;
        }

        .skeleton-paragraph.medium {
            width: 85%;
        }

        .skeleton-heading {
            height: 28px;
            width: 40%;
            margin: 30px 0 15px 0;
        }

        /* Success celebration animation */
        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        .celebrating {
            animation: celebrate 0.5s ease-in-out;
        }

        /* Ripple effect for button clicks */
        .ripple {
            position: relative;
            overflow: hidden;
        }

        .ripple::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            animation: rippleEffect 0.6s ease-out;
        }

        @keyframes rippleEffect {
            to {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        .error {
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #c62828;
        }

        /* Win Modal - Improved */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        /* Statistics Modal */
        .stats-modal .modal-content {
            max-width: 700px;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .stats-header h2 {
            margin: 0;
        }

        .reset-stats-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: background 0.2s;
        }

        .reset-stats-btn:hover {
            background: #d32f2f;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card.highlight {
            border-color: #0645ad;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
        }

        .stat-card-value {
            font-size: 2em;
            font-weight: 700;
            color: #0645ad;
            margin-bottom: 5px;
        }

        .stat-card-label {
            font-size: 0.85em;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-card-sublabel {
            font-size: 0.75em;
            color: #777;
            margin-top: 3px;
        }

        .recent-games-section {
            margin-top: 25px;
        }

        .recent-games-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        .recent-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid #0645ad;
        }

        .recent-game-item.gave-up {
            border-left-color: #f44336;
            opacity: 0.7;
        }

        .recent-game-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .recent-game-result {
            font-weight: 600;
            color: #0645ad;
        }

        .recent-game-result.gave-up {
            color: #f44336;
        }

        .recent-game-stats {
            display: flex;
            gap: 15px;
            font-size: 0.9em;
            color: #555;
        }

        .recent-game-date {
            font-size: 0.8em;
            color: #777;
        }

        .modal-content {
            background: var(--color-bg-primary);
            border-radius: var(--radius-xl);
            padding: var(--space-5);
            max-width: 650px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            animation: modalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalSlideIn {
            from {
                transform: scale(0.8) translateY(-50px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            color: #0645ad;
            font-size: 2.2em;
            margin-bottom: 25px;
            text-align: center;
        }

        .win-stats {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #e0e0e0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #555;
            font-size: 1em;
        }

        .stat-value {
            color: #0645ad;
            font-weight: 700;
            font-size: 1.2em;
        }

        .win-path {
            margin: 25px 0;
        }

        .win-path h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }

        .path-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #0645ad;
            transition: all 0.2s;
        }

        .path-item:hover {
            background: #e3f2fd;
            transform: translateX(5px);
        }

        .path-item-number {
            background: #0645ad;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85em;
            font-weight: 700;
            flex-shrink: 0;
        }

        /* NEW: Optimal path styling */
        .path-item.optimal {
            border-left-color: #28a745;
            background: #e8f5e9;
        }

        .path-item.optimal .path-item-number {
            background: #28a745;
        }

        .path-item.backtrack {
            border-left-color: #ff9800;
            background: #fff3e0;
            opacity: 0.85;
        }

        .path-item.backtrack .path-item-number {
            background: #ff9800;
        }

        .path-item.backtrack::after {
            content: '‚Ü©Ô∏è';
            margin-left: auto;
            font-size: 1.2em;
        }

        .performance-rating {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 25px;
            border: 3px solid;
        }

        .rating-perfect {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: white;
            border-color: #FF8C00;
        }

        .rating-excellent {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border-color: #2e7d32;
        }

        .rating-good {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border-color: #0d47a1;
        }

        .rating-completed {
            background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
            color: white;
            border-color: #4a148c;
        }

        /* NEW: Path comparison styling */
        .path-comparison {
            margin: 25px 0;
        }

        .path-comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .efficiency-badge {
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 700;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
        }

        .modal-btn {
            flex: 1;
            padding: var(--space-2) var(--space-3);
            border: none;
            border-radius: var(--radius-md);
            font-size: 1em;
            cursor: pointer;
            font-weight: var(--font-weight-bold);
            transition: all 0.2s ease;
        }

        .modal-btn.primary {
            background: var(--color-primary);
            color: white;
        }

        .modal-btn.primary:hover {
            background: var(--color-primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .modal-btn.secondary {
            background: var(--color-bg-tertiary);
            color: #333;
        }

        .modal-btn.secondary:hover {
            background: var(--color-border);
        }

        .share-notification {
            position: fixed;
            bottom: 100px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 2000;
            font-weight: 600;
        }

        .share-notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Search Overlay */
        .search-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            justify-content: center;
            align-items: flex-start;
            padding-top: 100px;
        }

        .search-overlay.active {
            display: flex;
        }

        .search-box {
            background: white;
            border-radius: 12px;
            padding: 25px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.1em;
            border: 2px solid #0645ad;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: #0b0080;
        }

        .search-results {
            margin-top: 20px;
            max-height: 450px;
            overflow-y: auto;
        }

        .search-result-item {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 6px;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-item strong {
            color: #0645ad;
            font-weight: 700;
        }

        .search-hint {
            text-align: center;
            color: #777;
            font-size: 0.9em;
            margin-top: 15px;
        }

        /* Hint System */
        .hint-badge {
            position: fixed;
            bottom: 90px;
            left: 20px;
            background: white;
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 12px 18px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 140;
            display: none;
            animation: slideInLeft 0.3s ease;
        }

        .hint-badge.active {
            display: block;
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hint-badge.warmer {
            border-color: #f59e0b;
            background: #fffbeb;
        }

        .hint-badge.colder {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .hint-badge.hot {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .hint-text {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }

        .hint-icon {
            font-size: 1.2em;
            margin-right: 6px;
        }

        /* Collapsible Sections */
        .section-toggle {
            cursor: pointer;
            margin-right: 8px;
            user-select: none;
            font-size: 1em;
            color: #0645ad;
            font-weight: bold;
            font-family: monospace;
            /* Large touch target */
            min-width: 44px;
            min-height: 44px;
            display: inline-flex;
            align-items: flex-end; /* Align to bottom of flex container */
            justify-content: center;
            vertical-align: middle; /* Align lower in the line */
            /* Prevent scroll on button */
            touch-action: manipulation;
            -webkit-touch-callout: none;
        }

        .section-toggle:hover {
            color: #0b0080;
        }

        .section-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            contain: layout style paint;
            content-visibility: auto;
        }

        /* === iOS-Quality Touch Optimizations === */

        /* Disable iOS tap highlight */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* Smooth momentum scrolling */
        body, .container, .game-area, .section-content, .path-panel {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-y: contain;
        }

        /* Prevent double-tap zoom */
        a, button, h2, .section-toggle {
            touch-action: manipulation;
        }

        /* Minimum 44x44pt touch targets */
        h2 {
            min-height: 44px;
            display: flex;
            align-items: center;
            padding: 8px 0;
        }

        /* Active states for touch feedback */
        .section-toggle:active {
            background: rgba(6, 69, 173, 0.15);
            border-radius: 4px;
            transform: scale(0.9);
            transition: all 0.08s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .wikipedia-article a:active {
            background: rgba(6, 69, 173, 0.1);
            border-radius: 3px;
            transform: scale(0.98);
            transition: all 0.08s cubic-bezier(0.4, 0, 0.2, 1);
        }

        button:active, .fab-menu-item:active {
            transform: scale(0.95);
        }

        .action-btn:active {
            transform: translateX(-2px) scale(0.96);
        }

        /* === Performance Optimizations === */

        /* Force GPU acceleration for smooth animations */
        .section-content,
        .wikipedia-article a,
        .fab-menu-button,
        .action-btn,
        h2 {
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .section-content {
            will-change: transform, opacity;
        }

        /* Keyboard focus for collapsible sections */
        h2:focus-visible {
            outline: 2px solid #7c3aed;
            outline-offset: 4px;
            border-radius: 4px;
        }

        .section-toggle:focus-visible {
            outline: 2px solid #7c3aed;
            outline-offset: 2px;
            border-radius: 3px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            /* Mobile font size reductions */
            body {
                font-size: 14px;
            }

            .wikipedia-article {
                font-size: 14px; /* Reduced from 16px */
            }

            .wikipedia-article h1 {
                font-size: 1.75em; /* Reduced from 2.5em */
            }

            .wikipedia-article h2 {
                font-size: 1.4em; /* Reduced from 1.75em */
            }

            .wikipedia-article h3 {
                font-size: 1.15em; /* Reduced from 1.35em */
            }

            .wikipedia-article h4 {
                font-size: 1.05em; /* Reduced from 1.15em */
            }

            .wikipedia-article p {
                font-size: 14px;
                line-height: 1.6;
            }

            /* Compact mobile header */
            .header-top {
                padding: 8px 12px;
                gap: 8px;
                transition: all 0.3s ease;
                flex-wrap: nowrap;
                min-height: 50px;
            }

            /* Scrolled state - even more compact */
            .header-top.scrolled {
                padding: 4px 12px;
                min-height: 40px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }

            /* Hide branding on mobile */
            .game-branding {
                display: none !important;
            }

            /* Compact stats layout */
            .header-left {
                flex: 0 0 auto;
                gap: 8px;
                align-items: center;
            }

            .header-stats {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .stat-item-compact {
                min-width: auto;
                padding: 2px 6px;
            }

            .stat-label-compact {
                font-size: 9px;
                margin-bottom: 0;
            }

            .stat-value-compact {
                font-size: 12px;
                font-weight: 600;
            }

            /* Compact target display */
            .header-center {
                flex: 1 1 auto;
                order: 2;
                min-width: 0;
            }

            .target-display {
                width: 100%;
                padding: 4px 8px;
                font-size: 11px;
            }

            .target-display strong {
                font-size: 12px;
            }

            /* Hide desktop actions */
            .header-right {
                display: none !important;
            }

            /* Scrolled state - smaller text */
            .header-top.scrolled .stat-label-compact {
                font-size: 8px;
            }

            .header-top.scrolled .stat-value-compact {
                font-size: 11px;
            }

            .header-top.scrolled .target-display {
                font-size: 10px;
                padding: 2px 6px;
            }

            .header-top.scrolled .target-display strong {
                font-size: 11px;
            }

            .container {
                flex-direction: column;
            }

            .toc-container {
                display: none; /* Hide TOC on mobile like Wikipedia mobile */
            }

            .content-area {
                padding: 15px; /* Reduced from 20px */
            }

            .path-panel {
                width: 100%;
                right: -100%;
            }

            /* Show FAB menu on mobile, hide desktop actions and path bar */
            .fab-menu {
                display: block !important;
                bottom: 15px;
                right: 15px;
            }

            .desktop-actions {
                display: none !important;
            }

            .path-bar {
                display: none; /* Hide path bar on mobile - use path panel instead */
            }

            .fab-menu-button {
                width: 55px;
                height: 55px;
            }

            .modal-content {
                padding: 25px;
                margin: 20px;
                max-width: 95%;
            }

            .modal-buttons {
                flex-direction: column;
            }

            /* Image caption mobile styles */
            .wikipedia-article .thumb,
            .wikipedia-article .thumb.tright,
            .wikipedia-article .thumb.tleft {
                float: none;
                clear: both;
                margin: 1em auto;
                max-width: 100%;
                width: auto !important;
            }

            .wikipedia-article figure,
            .wikipedia-article figure.mw-halign-right,
            .wikipedia-article figure.mw-halign-left {
                float: none;
                margin: 1em auto;
                max-width: 100%;
            }

            .wikipedia-article .thumbcaption,
            .wikipedia-article figcaption {
                font-size: 0.85em;
            }

            .wikipedia-article .infobox {
                float: none;
                margin: 1em auto;
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            .game-branding h1 {
                font-size: 1.1em;
            }

            .header-stats {
                gap: 12px;
            }

            .stat-value-compact {
                font-size: 0.9em;
            }

            #target-page-display {
                font-size: 1.1em;
            }
        }

        /* Hint highlight animation */
        .hint-highlight {
            background-color: gold !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            animation: hint-pulse 1s ease-in-out infinite;
            font-weight: 600 !important;
            color: #000 !important;
        }

        @keyframes hint-pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
        }

        /* Accessibility: Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            /* Keep essential animations but make them instant */
            .top-progress-bar {
                transition: opacity 0.01ms !important;
            }

            /* Disable decorative animations completely */
            .confetti,
            .shimmer-container,
            [class*="pulse"],
            [class*="bounce"],
            [class*="spin"] {
                animation: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Top Progress Bar -->
    <div id="top-progress-bar" class="top-progress-bar"></div>

    <div class="game-header" id="game-header">
        <div class="header-top">
            <!-- Left: Branding & Stats -->
            <div class="header-left">
                <div class="game-branding">
                    <span class="logo">üåê</span>
                    <h1>WikiPath <span style="font-size: 0.5em; color: #555; font-weight: 400;">v3.51.0</span></h1>
                </div>
                <div class="header-stats">
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Clicks</div>
                        <div class="stat-value-compact" id="click-counter">0</div>
                    </div>
                    <!-- NEW: Minimum clicks display -->
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Minimum</div>
                        <div class="stat-value-compact minimum" id="min-clicks-display">-</div>
                    </div>
                    <div class="stat-item-compact">
                        <div class="stat-label-compact">Time</div>
                        <div class="stat-value-compact" id="timer">0:00</div>
                    </div>
                </div>
            </div>

            <!-- Center: Target Page (Prominent) -->
            <div class="header-center">
                <div class="target-display">
                    <div class="target-label">
                        <span>üéØ</span>
                        <span>TARGET</span>
                    </div>
                    <div>
                        <span id="target-page-display">Loading...</span>
                        <span class="difficulty-badge" id="difficulty-badge"></span>
                    </div>
                    <div class="target-tooltip" id="target-tooltip">
                        <h4 id="tooltip-title"></h4>
                        <p id="tooltip-description"></p>
                    </div>
                </div>
            </div>

            <!-- Right: Mode Switch -->
            <div class="header-right">
                <button class="debug-toggle" id="debug-toggle" onclick="toggleDebugMode()">
                    üêõ Debug
                </button>
                <div class="mode-switch-container">
                    <div class="mode-switch-label">Mode</div>
                    <div class="mode-switch">
                        <button class="mode-switch-btn" id="explore-mode-btn" onclick="switchToExploreMode()">
                            Explore
                        </button>
                        <button class="mode-switch-btn active" id="daily-mode-btn" onclick="switchToDailyMode()">
                            Daily
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Minimalistic Path Bar -->
    <div class="path-bar" id="path-bar">
        <div class="path-breadcrumb" id="path-breadcrumb">
            <!-- Path steps will be dynamically inserted here -->
        </div>
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <h3>üêõ Debug Mode</h3>
        
        <div class="debug-section">
            <h4>üéÆ Custom Game Setup</h4>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-start-page" placeholder="Start Page (e.g., Albert Einstein)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-start"></div>
            </div>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-target-page" placeholder="Target Page (e.g., Physics)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-target"></div>
            </div>
            <div class="debug-error" id="debug-game-error"></div>
            <button class="debug-button" onclick="startDebugGame()">Start Custom Game</button>
            <button class="debug-button secondary" onclick="fillRandomPages()">Fill Random</button>
        </div>

        <div class="debug-section">
            <h4>üîç Page Preview</h4>
            <div class="debug-input-wrapper">
                <input type="text" class="debug-input" id="debug-preview-page" placeholder="Page Name (e.g., Mainframe)" autocomplete="off">
                <div class="debug-autocomplete" id="autocomplete-preview"></div>
            </div>
            <div class="debug-error" id="debug-preview-error"></div>
            <button class="debug-button" onclick="loadDebugPreview()">Load Preview</button>
            <button class="debug-button secondary" onclick="fillRandomPreview()">Fill Random</button>
        </div>
    </div>

    <!-- Path Panel (Collapsible) -->
    <div class="path-panel" id="path-panel" role="complementary" aria-label="Journey path panel">
        <div class="path-panel-header">
            <h3>üó∫Ô∏è Your Journey</h3>
            <button class="path-panel-close" onclick="togglePathPanel()" aria-label="Close journey panel">√ó</button>
        </div>
        <div class="path-panel-content">
            <div class="path-timeline" id="path-timeline"></div>
        </div>
    </div>

    <!-- Debug Console Toggle Button -->
    <button id="debug-console-toggle" onclick="toggleDebugConsole()" style="position: fixed; bottom: 15px; left: 15px; width: 45px; height: 45px; background: rgba(0,0,0,0.8); color: #0f0; border: 2px solid #0f0; border-radius: 50%; font-size: 18px; font-weight: bold; cursor: pointer; z-index: 10000; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
        üêõ
    </button>

    <!-- Debug Console Overlay -->
    <div id="debug-console" style="position: fixed; bottom: 80px; left: 10px; right: 10px; max-height: 200px; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 10px; padding: 10px; border-radius: 8px; overflow-y: auto; z-index: 9999; display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; gap: 5px;">
            <strong style="color: #fff;">Debug Console</strong>
            <div style="display: flex; gap: 5px;">
                <button onclick="clearDebugLog()" style="background: #ff9800; color: #fff; border: none; padding: 2px 8px; border-radius: 3px; font-size: 10px;">Clean</button>
                <button onclick="copyDebugLog()" style="background: #2196f3; color: #fff; border: none; padding: 2px 8px; border-radius: 3px; font-size: 10px;">Copy</button>
                <button onclick="toggleDebugConsole()" style="background: #f00; color: #fff; border: none; padding: 2px 8px; border-radius: 3px; font-size: 10px;">Close</button>
            </div>
        </div>
        <div id="debug-log" style="max-height: 150px; overflow-y: auto;"></div>
    </div>

    <!-- Floating Action Menu -->
    <div class="fab-menu" id="fab-menu">
        <button class="fab-menu-button" onclick="toggleFabMenu()">
            ‚ö°
        </button>
        <div class="fab-menu-items">
            <button class="fab-menu-item" onclick="togglePathPanel(); closeFabMenu();">
                <span class="emoji">üó∫Ô∏è</span>
                <span>View Path</span>
            </button>
            <!-- NEW: Hint button now functional -->
            <button class="fab-menu-item" id="hint-btn" onclick="showSolverHint(); closeFabMenu();" title="Get Hint (H)">
                <span class="emoji">üí°</span>
                <span>Get Hint</span>
                <span class="keyboard-shortcut">H</span>
            </button>
            <button class="fab-menu-item" onclick="openSearch(); closeFabMenu();">
                <span class="emoji">üîç</span>
                <span>Search</span>
                <span class="keyboard-shortcut">Ctrl+F</span>
            </button>
            <button class="fab-menu-item" onclick="openStats(); closeFabMenu();">
                <span class="emoji">üìä</span>
                <span>Statistics</span>
            </button>
            <div class="fab-menu-divider"></div>
            <button class="fab-menu-item" id="retry-btn" onclick="retryGame(); closeFabMenu();" title="Retry Game (R)">
                <span class="emoji">üîÑ</span>
                <span>Retry</span>
                <span class="keyboard-shortcut">R</span>
            </button>
            <button class="fab-menu-item danger" onclick="giveUp(); closeFabMenu();">
                <span class="emoji">üè≥Ô∏è</span>
                <span>Give Up</span>
            </button>
            <button class="fab-menu-item" id="new-game-btn" onclick="handleNewGame(); closeFabMenu();">
                <span class="emoji">üéÆ</span>
                <span>New Game</span>
                <span class="keyboard-shortcut">N</span>
            </button>
        </div>
    </div>

    <!-- Desktop Action Sidebar -->
    <div class="desktop-actions" role="toolbar" aria-label="Game actions">
        <button class="action-btn" onclick="openStats()" title="Statistics" aria-label="View statistics">
            <span class="emoji" aria-hidden="true">üìä</span>
            <span>Stats</span>
        </button>
        <button class="action-btn" onclick="openSearch()" title="Search (Ctrl+F)" aria-label="Search Wikipedia articles">
            <span class="emoji" aria-hidden="true">üîç</span>
            <span>Search</span>
        </button>
        <div class="action-divider" aria-hidden="true"></div>
        <button class="action-btn" onclick="showSolverHint()" title="Get Hint (H)" id="desktop-hint-btn" aria-label="Get hint (keyboard shortcut: H)">
            <span class="emoji" aria-hidden="true">üí°</span>
            <span>Hint</span>
        </button>
        <button class="action-btn" onclick="retryGame()" title="Retry Game (R)" id="desktop-retry-btn" aria-label="Retry current game (keyboard shortcut: R)">
            <span class="emoji" aria-hidden="true">üîÑ</span>
            <span>Retry</span>
        </button>
        <div class="action-divider" aria-hidden="true"></div>
        <button class="action-btn primary" onclick="handleNewGame()" title="New Game (N)" id="desktop-new-game-btn" aria-label="Start new game (keyboard shortcut: N)">
            <span class="emoji" aria-hidden="true">üéÆ</span>
            <span>New Game</span>
        </button>
        <button class="action-btn danger" onclick="giveUp()" title="Give Up" aria-label="Give up current game">
            <span class="emoji" aria-hidden="true">üè≥Ô∏è</span>
            <span>Give Up</span>
        </button>
    </div>

    <div class="container">
        <div class="toc-container" id="toc-container">
            <div class="toc-title">
                <span>Contents</span>
                <div class="toc-collapse-controls">
                    <button class="toc-collapse-btn" onclick="expandAllTOC()" title="Expand All">+</button>
                    <button class="toc-collapse-btn" onclick="collapseAllTOC()" title="Collapse All">‚àí</button>
                </div>
            </div>
            <ul class="toc-list" id="toc-list"></ul>
        </div>
        <div class="content-area" id="game-area">
            <div class="loading">Loading Wikipedia article...</div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal-overlay" id="win-modal" role="dialog" aria-modal="true" aria-labelledby="win-modal-title">
        <div class="modal-content">
            <h2 id="win-modal-title">üéâ Congratulations! üéâ</h2>
            <div class="win-stats">
                <div class="stat-row">
                    <span class="stat-label">Total Clicks:</span>
                    <span class="stat-value" id="final-clicks">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time Taken:</span>
                    <span class="stat-value" id="final-time">0:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Pages Visited:</span>
                    <span class="stat-value" id="final-pages">0</span>
                </div>
            </div>
            <div class="win-path" id="win-path"></div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="retryGame()">üîÑ Retry</button>
                <button class="modal-btn primary" onclick="shareResult()">üì§ Share</button>
                <button class="modal-btn secondary" onclick="startNewGame()">üéÆ New Game</button>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div class="modal-overlay stats-modal" id="stats-modal" role="dialog" aria-modal="true" aria-labelledby="stats-modal-title">
        <div class="modal-content">
            <div class="stats-header">
                <h2 id="stats-modal-title">üìä Your Statistics</h2>
                <button class="reset-stats-btn" onclick="stats.reset()" aria-label="Reset all statistics">Reset Stats</button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-streak">0</div>
                    <div class="stat-card-label">Daily Streak</div>
                    <div class="stat-card-sublabel">üî• days in a row</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-games">0</div>
                    <div class="stat-card-label">Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-wins">0</div>
                    <div class="stat-card-label">Wins</div>
                    <div class="stat-card-sublabel" id="stat-winrate">0% win rate</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-best-clicks">-</div>
                    <div class="stat-card-label">Best Clicks</div>
                    <div class="stat-card-sublabel">üèÜ personal record</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-card-value" id="stat-best-time">-</div>
                    <div class="stat-card-label">Best Time</div>
                    <div class="stat-card-sublabel">‚ö° fastest win</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-avg-clicks">-</div>
                    <div class="stat-card-label">Avg Clicks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-value" id="stat-avg-time">-</div>
                    <div class="stat-card-label">Avg Time</div>
                </div>
            </div>

            <div class="recent-games-section">
                <h3>üìú Recent Games</h3>
                <div id="recent-games-list"></div>
            </div>

            <div class="modal-buttons" style="margin-top: 25px;">
                <button class="modal-btn secondary" onclick="closeStats()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Notification -->
    <div class="share-notification" id="share-notification">
        ‚úì Copied to clipboard!
    </div>

    <!-- Search Overlay (Ctrl+F) -->
    <div class="search-overlay" id="search-overlay">
        <div class="search-box">
            <input type="text" class="search-input" id="search-input" placeholder="Search within current article...">
            <div class="search-results" id="search-results"></div>
            <div class="search-hint">Press Ctrl+F to search ‚Ä¢ ESC to close</div>
        </div>
    </div>

    <!-- Link Preview Tooltip -->
    <div class="link-preview" id="link-preview">
        <div class="link-preview-title" id="preview-title"></div>
        <div class="link-preview-text" id="preview-text"></div>
    </div>

    <!-- Hint Badge -->
    <div class="hint-badge" id="hint-badge">
        <span class="hint-icon" id="hint-icon">üî•</span>
        <span class="hint-text" id="hint-text">Getting warmer!</span>
    </div>

    <script>
        // ======================
        // DEBUG CONSOLE
        // ======================
        const debugConsole = document.getElementById('debug-console');
        const debugLog = document.getElementById('debug-log');
        let logCount = 0;
        const maxLogs = 50;

        // Toggle debug console visibility
        function toggleDebugConsole() {
            const isVisible = debugConsole.style.display !== 'none';
            debugConsole.style.display = isVisible ? 'none' : 'block';
        }

        // Hide debug console by default
        debugConsole.style.display = 'none';

        // Override console.log to show in our debug panel
        const originalLog = console.log;
        console.log = function(...args) {
            originalLog.apply(console, args);

            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');

            const logEntry = document.createElement('div');
            logEntry.style.marginBottom = '2px';
            logEntry.style.borderBottom = '1px solid #333';
            logEntry.style.paddingBottom = '2px';
            logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;

            debugLog.insertBefore(logEntry, debugLog.firstChild);

            // Limit log entries
            logCount++;
            if (logCount > maxLogs) {
                debugLog.removeChild(debugLog.lastChild);
            }

            // Auto-scroll to top (newest)
            debugLog.scrollTop = 0;
        };

        // Clear debug log
        function clearDebugLog() {
            debugLog.innerHTML = '';
            logCount = 0;
            console.log('Debug log cleared');
        }

        // Copy debug log to clipboard
        function copyDebugLog() {
            const allLogs = Array.from(debugLog.children)
                .map(entry => entry.textContent)
                .reverse()
                .join('\n');

            navigator.clipboard.writeText(allLogs).then(() => {
                alert('Debug log copied to clipboard!');
            }).catch(err => {
                console.log('Copy failed:', err);
                alert('Copy failed - see console');
            });
        }

        // ======================
        // TOP PROGRESS BAR
        // ======================
        let progressInterval = null;
        let currentProgress = 0;

        function showProgressBar() {
            const bar = document.getElementById('top-progress-bar');
            bar.classList.remove('complete');
            bar.classList.add('loading');
            currentProgress = 0;
            bar.style.width = '0%';

            // Simulate progress with incremental updates
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                if (currentProgress < 90) {
                    // Quick progress to 30%, then slow down
                    if (currentProgress < 30) {
                        currentProgress += 15;
                    } else if (currentProgress < 60) {
                        currentProgress += 5;
                    } else {
                        currentProgress += 2;
                    }
                    bar.style.width = currentProgress + '%';
                }
            }, 100);
        }

        function completeProgressBar() {
            clearInterval(progressInterval);
            const bar = document.getElementById('top-progress-bar');
            bar.style.width = '100%';

            // Wait a moment then hide
            setTimeout(() => {
                bar.classList.remove('loading');
                bar.classList.add('complete');

                // Reset after animation
                setTimeout(() => {
                    bar.classList.remove('complete');
                    bar.style.width = '0%';
                }, 700);
            }, 200);
        }

        // ======================
        // WIKIPEDIA PATH SOLVER
        // ======================

        class WikipathSolverBrowser {
            constructor() {
                this.cache = new Map();
                this.apiDelay = 150;
            }

            async getOutgoingLinks(pageTitle) {
                const cacheKey = `out:${pageTitle}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const url = `https://en.wikipedia.org/w/api.php?` +
                        `action=query&titles=${encodeURIComponent(pageTitle)}` +
                        `&prop=links&pllimit=max&format=json&origin=*&plnamespace=0`;

                    const response = await fetch(url);
                    const data = await response.json();

                    // Use Wikipedia's normalized title if provided
                    let actualTitle = pageTitle;
                    if (data.query?.normalized) {
                        actualTitle = data.query.normalized[0].to;
                        console.log('[getOutgoingLinks] Wikipedia normalized title:', 
                            data.query.normalized[0].from, '‚Üí', actualTitle);
                        // Cache under both the requested and normalized title
                        if (pageTitle !== actualTitle) {
                            this.cache.set(`out:${actualTitle}`, null); // Will be filled below
                        }
                    }

                    const pages = data.query?.pages || {};
                    const pageId = Object.keys(pages)[0];

                    if (pageId === '-1') {
                        console.log('[getOutgoingLinks] Page not found:', pageTitle);
                        return [];
                    }

                    const links = pages[pageId]?.links || [];
                    // FILTER OUT non-clickable links (same as game UI does)
                    // Only include links that don't contain ':' (filters out Wikipedia:, File:, Category:, etc.)
                    const linkTitles = links
                        .map(link => link.title)
                        .filter(title => !title.includes(':'));

                    this.cache.set(cacheKey, linkTitles);
                    await this.delay(this.apiDelay);

                    return linkTitles;
                } catch (error) {
                    console.error(`Error fetching links:`, error);
                    return [];
                }
            }

            async getIncomingLinks(pageTitle) {
                const cacheKey = `in:${pageTitle}`;
                if (this.cache.has(cacheKey)) {
                    return this.cache.get(cacheKey);
                }

                try {
                    const url = `https://en.wikipedia.org/w/api.php?` +
                        `action=query&titles=${encodeURIComponent(pageTitle)}` +
                        `&prop=linkshere&lhlimit=max&format=json&origin=*&lhnamespace=0`;

                    const response = await fetch(url);
                    const data = await response.json();

                    // Use Wikipedia's normalized title if provided
                    let actualTitle = pageTitle;
                    if (data.query?.normalized) {
                        actualTitle = data.query.normalized[0].to;
                        console.log('[getIncomingLinks] Wikipedia normalized title:', 
                            data.query.normalized[0].from, '‚Üí', actualTitle);
                        // Cache under both the requested and normalized title
                        if (pageTitle !== actualTitle) {
                            this.cache.set(`in:${actualTitle}`, null); // Will be filled below
                        }
                    }

                    const pages = data.query?.pages || {};
                    const pageId = Object.keys(pages)[0];

                    if (pageId === '-1') {
                        console.log('[getIncomingLinks] Page not found:', pageTitle);
                        return [];
                    }

                    const linkshere = pages[pageId]?.linkshere || [];
                    // FILTER OUT non-clickable links (same as game UI does)
                    // Only include links that don't contain ':' (filters out Wikipedia:, File:, Category:, etc.)
                    const linkTitles = linkshere
                        .map(link => link.title)
                        .filter(title => !title.includes(':'));

                    this.cache.set(cacheKey, linkTitles);
                    await this.delay(this.apiDelay);

                    return linkTitles;
                } catch (error) {
                    console.error(`Error fetching incoming links:`, error);
                    return [];
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            normalizeTitle(title) {
                // Replace underscores with spaces and trim
                title = title.trim().replace(/_/g, ' ');
                
                // Wikipedia capitalizes the first letter of each word (except small words in middle)
                // But for simplicity, we'll just capitalize the first letter and keep the rest as-is
                // This matches Wikipedia's actual behavior for most article titles
                if (title.length === 0) return title;
                
                // Capitalize first character, keep rest as provided
                return title.charAt(0).toUpperCase() + title.slice(1);
            }

            async findShortestPath(startPage, targetPage, maxDepth = 5) {
                console.log(`Finding path from "${startPage}" to "${targetPage}"...`);
                
                // Don't normalize - let Wikipedia API handle title formatting
                // Just clean up underscores to spaces
                startPage = startPage.trim().replace(/_/g, ' ');
                targetPage = targetPage.trim().replace(/_/g, ' ');

                if (startPage.toLowerCase() === targetPage.toLowerCase()) {
                    return { found: true, path: [startPage], length: 0, pagesExplored: 0 };
                }

                const forwardQueue = [[startPage]];
                const forwardVisited = new Map([[startPage, [startPage]]]);
                const backwardQueue = [[targetPage]];
                const backwardVisited = new Map([[targetPage, [targetPage]]]);

                let depth = 0;
                let pagesExplored = 0;

                while (forwardQueue.length > 0 || backwardQueue.length > 0) {
                    if (depth > maxDepth) {
                        return {
                            found: false,
                            path: null,
                            length: null,
                            pagesExplored,
                            message: `No path found within ${maxDepth} degrees`
                        };
                    }

                    // Forward search
                    if (forwardQueue.length > 0) {
                        const forwardSize = forwardQueue.length;
                        for (let i = 0; i < forwardSize; i++) {
                            const currentPath = forwardQueue.shift();
                            const currentPage = currentPath[currentPath.length - 1];

                            if (backwardVisited.has(currentPage)) {
                                const backwardPath = backwardVisited.get(currentPage);
                                const completePath = [...currentPath, ...backwardPath.reverse().slice(1)];
                                return {
                                    found: true,
                                    path: completePath,
                                    length: completePath.length - 1,
                                    pagesExplored
                                };
                            }

                            const links = await this.getOutgoingLinks(currentPage);
                            pagesExplored++;

                            for (const link of links) {
                                if (!forwardVisited.has(link)) {
                                    const newPath = [...currentPath, link];
                                    forwardVisited.set(link, newPath);
                                    forwardQueue.push(newPath);

                                    if (backwardVisited.has(link)) {
                                        const backwardPath = backwardVisited.get(link);
                                        const completePath = [...newPath, ...backwardPath.reverse().slice(1)];
                                        return {
                                            found: true,
                                            path: completePath,
                                            length: completePath.length - 1,
                                            pagesExplored
                                        };
                                    }
                                }
                            }
                        }
                    }

                    // Backward search
                    if (backwardQueue.length > 0) {
                        const backwardSize = backwardQueue.length;
                        for (let i = 0; i < backwardSize; i++) {
                            const currentPath = backwardQueue.shift();
                            const currentPage = currentPath[currentPath.length - 1];

                            if (forwardVisited.has(currentPage)) {
                                const forwardPath = forwardVisited.get(currentPage);
                                const completePath = [...forwardPath, ...currentPath.reverse().slice(1)];
                                return {
                                    found: true,
                                    path: completePath,
                                    length: completePath.length - 1,
                                    pagesExplored
                                };
                            }

                            const links = await this.getIncomingLinks(currentPage);
                            pagesExplored++;

                            for (const link of links) {
                                if (!backwardVisited.has(link)) {
                                    const newPath = [...currentPath, link];
                                    backwardVisited.set(link, newPath);
                                    backwardQueue.push(newPath);

                                    if (forwardVisited.has(link)) {
                                        const forwardPath = forwardVisited.get(link);
                                        const completePath = [...forwardPath, ...newPath.reverse().slice(1)];
                                        return {
                                            found: true,
                                            path: completePath,
                                            length: completePath.length - 1,
                                            pagesExplored
                                        };
                                    }
                                }
                            }
                        }
                    }

                    depth++;
                }

                return { found: false, path: null, length: null, pagesExplored };
            }

            async getBestNextLink(currentPage, targetPage) {
                console.log('[getBestNextLink] Called with:', { currentPage, targetPage });
                const result = await this.findShortestPath(currentPage, targetPage, 4);
                console.log('[getBestNextLink] Path found:', result.path);

                if (!result.found || !result.path || result.path.length < 2) {
                    console.log('[getBestNextLink] No valid path found');
                    return { success: false, message: 'Could not find optimal path' };
                }

                console.log('[getBestNextLink] Returning path[1]:', result.path[1]);
                return {
                    success: true,
                    bestLink: result.path[1],
                    optimalPath: result.path,
                    optimalLength: result.length,
                    hint: `Try clicking: "${result.path[1]}"`
                };
            }
        }

        // Create global instance
        const wikipathSolver = new WikipathSolverBrowser();
        console.log('‚úì Wikipedia Path Solver ready!');

        // Store optimal path globally
        let optimalPathData = null;

        // Show hint using the solver
        async function showSolverHint() {
            console.log('=== showSolverHint called ===');
            if (!gameState.currentPage || !gameState.targetPage || gameState.hasWon) {
                showNotification('Hint not available right now');
                console.log('Hint blocked:', { currentPage: gameState.currentPage, targetPage: gameState.targetPage, hasWon: gameState.hasWon });
                return;
            }

            const minClicksDisplay = document.getElementById('min-clicks-display');
            const originalText = minClicksDisplay.textContent;
            minClicksDisplay.textContent = '...';
            minClicksDisplay.classList.add('loading');

            try {
                console.log('=== HINT REQUEST ===');
                console.log('Current page:', gameState.currentPage);
                console.log('Target page:', gameState.targetPage);
                
                let bestLink = null;
                let optimalPath = null;
                
                // STRATEGY 1: Use cached optimal path if available
                if (optimalPathData && optimalPathData.found && optimalPathData.path) {
                    console.log('Using cached optimal path:', optimalPathData.path);
                    
                    // Find current page in the optimal path (case-insensitive, normalized)
                    const normalizedCurrent = gameState.currentPage.replace(/_/g, ' ').trim().toLowerCase();
                    const pathIndex = optimalPathData.path.findIndex(page => 
                        page.replace(/_/g, ' ').trim().toLowerCase() === normalizedCurrent
                    );
                    
                    console.log('Current page index in optimal path:', pathIndex);
                    
                    if (pathIndex !== -1 && pathIndex < optimalPathData.path.length - 1) {
                        // Found current page in path, return next page
                        bestLink = optimalPathData.path[pathIndex + 1];
                        optimalPath = optimalPathData.path;
                        console.log('‚úì Using cached path, next link:', bestLink);
                    } else {
                        console.log('‚ö† Current page not in optimal path or at end, recalculating...');
                    }
                }
                
                // STRATEGY 2: Recalculate if we couldn't use cached path
                if (!bestLink) {
                    console.log('Recalculating path from current position...');
                    const hint = await wikipathSolver.getBestNextLink(
                        gameState.currentPage,
                        gameState.targetPage
                    );
                    console.log('Hint result:', hint);
                    
                    if (hint.success) {
                        bestLink = hint.bestLink;
                        optimalPath = hint.optimalPath;
                        console.log('Suggested next link:', bestLink);
                        if (hint.optimalPath) {
                            console.log('Full path:', hint.optimalPath.join(' ‚Üí '));
                        }
                    } else {
                        showNotification('Could not generate hint');
                        console.log('Hint generation failed');
                        minClicksDisplay.textContent = originalText;
                        minClicksDisplay.classList.remove('loading');
                        return;
                    }
                }

                // SAFETY CHECK: Don't suggest the current page
                const normalizedBestLink = bestLink.replace(/_/g, ' ').trim().toLowerCase();
                const normalizedCurrentPage = gameState.currentPage.replace(/_/g, ' ').trim().toLowerCase();
                
                console.log('=== SAFETY CHECK ===');
                console.log('Raw bestLink:', bestLink);
                console.log('Raw currentPage:', gameState.currentPage);
                console.log('Normalized bestLink:', normalizedBestLink);
                console.log('Normalized currentPage:', normalizedCurrentPage);
                console.log('Are they equal?', normalizedBestLink === normalizedCurrentPage);
                if (optimalPath) {
                    console.log('Path[0] (should be current):', optimalPath[0]);
                    console.log('Path[1] (the suggestion):', optimalPath[1]);
                }
                
                if (normalizedBestLink === normalizedCurrentPage) {
                    console.error('‚ö†Ô∏è BUG DETECTED: Hint is suggesting current page!');
                    console.error('Current page:', gameState.currentPage);
                    console.error('Suggested link:', bestLink);
                    console.error('Full path:', optimalPath);
                    console.error('This means path[0] and path[1] are the same, or there\'s a title mismatch');
                    showNotification('‚ö†Ô∏è Hint error: Already on suggested page. Try again.');
                    minClicksDisplay.textContent = originalText;
                    minClicksDisplay.classList.remove('loading');
                    return;
                }
                
                // Find the link on the page using the data-page-title attribute
                const allLinks = document.querySelectorAll('#game-area a[data-page-title]');
                console.log('Total links with data-page-title:', allLinks.length);
                
                // Debug: log first few links
                if (allLinks.length > 0) {
                    console.log('First 5 links:', Array.from(allLinks).slice(0, 5).map(l => l.getAttribute('data-page-title')));
                }
                
                let foundLink = null;
                
                // The bestLink might have spaces or underscores, normalize both for comparison
                const normalizedHint = bestLink.replace(/_/g, ' ');
                console.log('Looking for:', normalizedHint);
                
                for (const link of allLinks) {
                    const pageTitle = link.getAttribute('data-page-title');
                    const normalizedPageTitle = pageTitle.replace(/_/g, ' ');
                    
                    if (normalizedPageTitle === normalizedHint) {
                        foundLink = link;
                        console.log('‚úì Found link!');
                        break;
                    }
                }
                
                if (foundLink) {
                    console.log('Scrolling and highlighting link...');
                    
                    // Check if link is inside a collapsed section and expand it
                    const headers = document.querySelectorAll('#game-area h2');
                    for (const header of headers) {
                        const wrapper = header._collapsibleWrapper;
                        if (wrapper && wrapper.contains(foundLink)) {
                            // Link is in this section - check if collapsed
                            if (wrapper.style.display === 'none') {
                                console.log('Expanding collapsed section:', header.textContent);
                                wrapper.style.display = 'block';
                                const toggleBtn = header._collapsibleToggle;
                                if (toggleBtn) {
                                    toggleBtn.textContent = '[-]';
                                }
                            }
                            break;
                        }
                    }
                    
                    // Scroll to the link smoothly
                    foundLink.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    // Add gold highlight
                    foundLink.classList.add('hint-highlight');
                    console.log('Highlight class added');
                    
                    // Show notification
                    showNotification(`üí° Hint: Highlighted on page`);

                    // Mark that a hint was used on this page
                    gameState.hintsUsed++;
                    if (gameState.path.length > 0) {
                        gameState.path[gameState.path.length - 1].hintUsed = true;
                        game.updatePathDisplay();
                    }

                    // Remove highlight after 3 seconds
                    setTimeout(() => {
                        foundLink.classList.remove('hint-highlight');
                        console.log('Highlight removed');
                    }, 3000);
                } else {
                    // Link not found on page (might be further down and need scrolling/loading)
                    showNotification(`üí° Hint: Look for "${bestLink}"`);

                    // Mark that a hint was used on this page
                    gameState.hintsUsed++;
                    if (gameState.path.length > 0) {
                        gameState.path[gameState.path.length - 1].hintUsed = true;
                        game.updatePathDisplay();
                    }

                    console.log('‚ö† Link not found on current page view:', bestLink);
                    console.log('All available links:', Array.from(allLinks).map(l => l.getAttribute('data-page-title')));
                }
                
                if (optimalPath) {
                    console.log('Optimal path:', optimalPath.join(' ‚Üí '));
                }
            } catch (error) {
                console.error('Hint error:', error);
                showNotification('Error generating hint');
            } finally {
                minClicksDisplay.textContent = originalText;
                minClicksDisplay.classList.remove('loading');
            }
        }

        // Calculate minimum clicks when game starts
        async function calculateMinimumClicks(startPage, targetPage) {
            const minClicksDisplay = document.getElementById('min-clicks-display');
            minClicksDisplay.textContent = '...';
            minClicksDisplay.classList.add('loading');

            try {
                console.log('Calculating minimum clicks...');
                const result = await wikipathSolver.findShortestPath(startPage, targetPage, 5);
                
                if (result.found) {
                    optimalPathData = result;
                    minClicksDisplay.textContent = result.length;
                    minClicksDisplay.classList.remove('loading');
                    console.log(`‚úì Minimum: ${result.length} clicks`);
                    console.log(`‚úì Path: ${result.path.join(' ‚Üí ')}`);
                } else {
                    optimalPathData = null;
                    minClicksDisplay.textContent = '?';
                    minClicksDisplay.classList.remove('loading');
                    console.log('Could not find path within 5 degrees');
                }
            } catch (error) {
                console.error('Error calculating minimum clicks:', error);
                optimalPathData = null;
                minClicksDisplay.textContent = '?';
                minClicksDisplay.classList.remove('loading');
            }
        }

        // ======================
        // CONFIGURATION
        // ======================
        
        // Feature Flags
        const SHOW_DEBUG_MODE = true;
        
        // Initialize debug mode visibility
        if (SHOW_DEBUG_MODE) {
            document.addEventListener('DOMContentLoaded', () => {
                document.getElementById('debug-toggle').style.display = 'inline-block';
                
                const debugMode = localStorage.getItem('wikipath_debug_mode') === 'true';
                if (debugMode) {
                    document.getElementById('debug-toggle').classList.add('active');
                    document.getElementById('debug-panel').classList.add('active');
                }
                
                setupAutocomplete('debug-start-page', 'autocomplete-start');
                setupAutocomplete('debug-target-page', 'autocomplete-target');
                setupAutocomplete('debug-preview-page', 'autocomplete-preview');
            });
        }
        
        // ======================
        // DAILY CHALLENGE SYSTEM
        // ======================
        
        function getTodayDateString() {
            const today = new Date();
            return today.toISOString().split('T')[0];
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function dateToSeed(dateString) {
            return dateString.split('-').map(Number).reduce((acc, val) => acc * 100 + val, 0);
        }

        function getSeededRandomIndex(array, seed, offset = 0) {
            const adjustedSeed = seed + offset;
            return Math.floor(seededRandom(adjustedSeed) * array.length);
        }

        const POPULAR_PAGES = {
            easy: [
                "United States", "World War II", "Python (programming language)",
                "Solar System", "Moon", "Sun", "Earth", "Water",
                "Dog", "Cat", "Football", "Basketball", "Music",
                "Internet", "Google", "Apple Inc.", "Microsoft",
                "New York City", "London", "Paris", "Pizza", "Coffee"
            ],
            medium: [
                "Albert Einstein", "William Shakespeare", "Leonardo da Vinci",
                "DNA", "Climate change", "Artificial intelligence", "The Beatles",
                "Mars", "Isaac Newton", "Charles Darwin", "Quantum mechanics",
                "Renaissance", "French Revolution", "Industrial Revolution",
                "Tiger", "Lion", "Elephant", "Blue whale", "Amazon rainforest",
                "Mount Everest", "Pacific Ocean", "European Union", "United Nations",
                "Olympic Games", "Chess", "Guitar", "Piano", "Vincent van Gogh",
                "Pablo Picasso", "Mona Lisa", "Beethoven", "Mozart", "Star Wars",
                "Harry Potter", "The Lord of the Rings", "Facebook", "Twitter",
                "Great Wall of China", "Eiffel Tower", "Statue of Liberty",
                "Pyramids of Giza", "Taj Mahal", "Machu Picchu", "Colosseum"
            ],
            hard: [
                "Ancient Rome", "Democracy", "Capitalism", "Socialism",
                "Philosophy", "Psychology", "Mathematics", "Physics",
                "Chemistry", "Biology", "Medicine", "Computer", "Smartphone",
                "Electric car", "Space exploration", "International Space Station",
                "Hubble Space Telescope", "Big Bang", "Black hole", "Galaxy",
                "Milky Way", "Jupiter", "Saturn", "Dinosaur", "Evolution",
                "Photosynthesis", "Periodic table", "Napoleon", "Julius Caesar",
                "Cleopatra", "Alexander the Great", "Genghis Khan",
                "Abraham Lincoln", "George Washington", "Martin Luther King Jr.",
                "Mahatma Gandhi", "Nelson Mandela", "Winston Churchill"
            ],
            expert: [
                "COVID-19 pandemic", "Game of Thrones", "Netflix",
                "Chocolate", "Tea", "Sushi", "Pasta", "Rice", "Bread",
                "Potato", "Tomato", "Wine", "Beer", "Tokyo", "Beijing",
                "Rome", "Athens", "Cairo", "Istanbul", "Moscow",
                "Amazon (company)", "Tesla, Inc.", "SpaceX", "NASA", "Nobel Prize",
                "Adolf Hitler"
            ]
        };

        const ALL_PAGES = [
            ...POPULAR_PAGES.easy,
            ...POPULAR_PAGES.medium,
            ...POPULAR_PAGES.hard,
            ...POPULAR_PAGES.expert
        ];

        function getPageDifficulty(pageName) {
            for (const [difficulty, pages] of Object.entries(POPULAR_PAGES)) {
                if (pages.includes(pageName)) {
                    return difficulty;
                }
            }
            return 'medium';
        }

        function calculateChallengeDifficulty(startPage, targetPage) {
            const startDiff = getPageDifficulty(startPage);
            const targetDiff = getPageDifficulty(targetPage);
            
            const difficultyScore = {
                'easy': 1,
                'medium': 2,
                'hard': 3,
                'expert': 4
            };
            
            const avgScore = (difficultyScore[startDiff] + difficultyScore[targetDiff]) / 2;
            
            if (avgScore <= 1.5) return 'easy';
            if (avgScore <= 2.5) return 'medium';
            if (avgScore <= 3.5) return 'hard';
            return 'expert';
        }

        // ======================
        // STATISTICS SYSTEM
        // ======================
        const stats = {
            totalGamesPlayed: 0,
            totalWins: 0,
            totalGiveUps: 0,
            bestClicks: null,
            bestTime: null,
            averageClicks: 0,
            averageTime: 0,
            dailyStreak: 0,
            lastDailyDate: null,
            recentGames: [],
            
            load() {
                const saved = localStorage.getItem('wikipath_stats');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(this, data);
                }
            },
            
            save() {
                const data = {
                    totalGamesPlayed: this.totalGamesPlayed,
                    totalWins: this.totalWins,
                    totalGiveUps: this.totalGiveUps,
                    bestClicks: this.bestClicks,
                    bestTime: this.bestTime,
                    averageClicks: this.averageClicks,
                    averageTime: this.averageTime,
                    dailyStreak: this.dailyStreak,
                    lastDailyDate: this.lastDailyDate,
                    recentGames: this.recentGames
                };
                localStorage.setItem('wikipath_stats', JSON.stringify(data));
            },
            
            recordGame(won, clicks, timeInSeconds, path, mode, gaveUp = false) {
                this.totalGamesPlayed++;
                
                if (won) {
                    this.totalWins++;
                    
                    if (this.bestClicks === null || clicks < this.bestClicks) {
                        this.bestClicks = clicks;
                    }
                    
                    if (this.bestTime === null || timeInSeconds < this.bestTime) {
                        this.bestTime = timeInSeconds;
                    }
                    
                    if (mode === 'daily') {
                        const today = getTodayDateString();
                        if (this.lastDailyDate) {
                            const yesterday = new Date();
                            yesterday.setDate(yesterday.getDate() - 1);
                            const yesterdayStr = yesterday.toISOString().split('T')[0];
                            
                            if (this.lastDailyDate === yesterdayStr) {
                                this.dailyStreak++;
                            } else if (this.lastDailyDate !== today) {
                                this.dailyStreak = 1;
                            }
                        } else {
                            this.dailyStreak = 1;
                        }
                        this.lastDailyDate = today;
                    }
                }
                
                if (gaveUp) {
                    this.totalGiveUps++;
                }
                
                if (won) {
                    const totalClicksSum = this.averageClicks * (this.totalWins - 1) + clicks;
                    this.averageClicks = Math.round(totalClicksSum / this.totalWins * 10) / 10;
                    
                    const totalTimeSum = this.averageTime * (this.totalWins - 1) + timeInSeconds;
                    this.averageTime = Math.round(totalTimeSum / this.totalWins);
                }
                
                this.recentGames.unshift({
                    date: new Date().toISOString(),
                    won,
                    clicks,
                    time: timeInSeconds,
                    pathLength: path.length,
                    mode,
                    gaveUp
                });
                
                if (this.recentGames.length > 10) {
                    this.recentGames = this.recentGames.slice(0, 10);
                }
                
                this.save();
            },
            
            reset() {
                if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                    localStorage.removeItem('wikipath_stats');
                    this.totalGamesPlayed = 0;
                    this.totalWins = 0;
                    this.totalGiveUps = 0;
                    this.bestClicks = null;
                    this.bestTime = null;
                    this.averageClicks = 0;
                    this.averageTime = 0;
                    this.dailyStreak = 0;
                    this.lastDailyDate = null;
                    this.recentGames = [];
                    this.save();
                    alert('Statistics reset successfully!');
                }
            }
        };

        stats.load();

        // ======================
        // GAME STATE
        // ======================
        const gameState = {
            startPage: '',
            targetPage: '',
            currentPage: '',
            clickCount: 0,
            totalClicks: 0,
            visitedPages: new Set(),
            path: [], // Array of {page: string, isBacktrack: boolean, hintUsed: boolean}
            startTime: null,
            elapsedTime: 0,
            isDailyMode: localStorage.getItem('wikipath_mode') === 'explore' ? false : true,
            dailyDate: getTodayDateString(),
            startDescription: '',
            targetDescription: '',
            hasWon: false,
            gaveUp: false,
            difficulty: 'medium',
            hintsUsed: 0
        };

        // ======================
        // URL STATE MANAGEMENT
        // ======================
        function updateUrl(start, target, current, clicks, totalClicks, visited, path, startTime) {
            const params = new URLSearchParams();
            params.set('start', start);
            params.set('target', target);
            params.set('current', current);
            params.set('clicks', clicks);
            params.set('totalClicks', totalClicks);
            params.set('visited', visited.join(','));
            params.set('path', JSON.stringify(path));
            params.set('startTime', startTime);

            if (gameState.isDailyMode) {
                params.set('daily', gameState.dailyDate);
            }

            const newUrl = `${window.location.pathname}?${params.toString()}`;

            // Store state in history for back button
            const state = {
                start,
                target,
                current,
                clicks,
                totalClicks,
                visited,
                path,
                startTime,
                isDailyMode: gameState.isDailyMode,
                dailyDate: gameState.dailyDate
            };

            console.log('Pushing state to history:', newUrl);
            window.history.pushState(state, '', newUrl);
        }

        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            let path = [];
            try {
                const pathParam = params.get('path');
                if (pathParam) {
                    // Try to parse as JSON first (new format)
                    path = JSON.parse(pathParam);
                    // If it's an array of strings (old format), convert to new format
                    if (path.length > 0 && typeof path[0] === 'string') {
                        path = path.map(p => ({ page: p, isBacktrack: false }));
                    }
                }
            } catch (e) {
                // Fallback to old format (comma-separated strings)
                const pathParam = params.get('path');
                if (pathParam) {
                    path = pathParam.split(',').map(p => ({ page: p, isBacktrack: false }));
                }
            }

            return {
                start: params.get('start'),
                target: params.get('target'),
                current: params.get('current'),
                clicks: parseInt(params.get('clicks')) || 0,
                totalClicks: parseInt(params.get('totalClicks')) || 0,
                visited: params.get('visited') ? params.get('visited').split(',') : [],
                path: path,
                startTime: parseInt(params.get('startTime')) || Date.now(),
                daily: params.get('daily')
            };
        }

        function clearUrl() {
            window.history.pushState({}, '', window.location.pathname);
        }

        // ======================
        // MODE SWITCHING
        // ======================
        function switchToExploreMode() {
            if (!gameState.isDailyMode) return;
            
            gameState.isDailyMode = false;
            localStorage.setItem('wikipath_mode', 'explore');
            
            const savedExploreStart = localStorage.getItem('wikipath_explore_start');
            const savedExploreTarget = localStorage.getItem('wikipath_explore_target');
            
            if (savedExploreStart && savedExploreTarget) {
                clearUrl();
                const params = new URLSearchParams();
                params.set('start', savedExploreStart);
                params.set('target', savedExploreTarget);
                params.set('current', savedExploreStart);
                params.set('clicks', '0');
                params.set('totalClicks', '0');
                params.set('visited', savedExploreStart);
                params.set('path', savedExploreStart);
                params.set('startTime', Date.now().toString());
                
                const newUrl = `${window.location.pathname}?${params.toString()}`;
                window.location.href = newUrl;
            } else {
                clearUrl();
                location.reload();
            }
        }

        function switchToDailyMode() {
            if (gameState.isDailyMode) return;
            
            if (!gameState.isDailyMode && gameState.startPage && gameState.targetPage) {
                localStorage.setItem('wikipath_explore_start', gameState.startPage);
                localStorage.setItem('wikipath_explore_target', gameState.targetPage);
            }
            
            gameState.isDailyMode = true;
            gameState.dailyDate = getTodayDateString();
            localStorage.setItem('wikipath_mode', 'daily');
            
            clearUrl();
            location.reload();
        }

        function updateModeUI() {
            const exploreBtn = document.getElementById('explore-mode-btn');
            const dailyBtn = document.getElementById('daily-mode-btn');
            const newGameBtn = document.getElementById('new-game-btn');

            if (gameState.isDailyMode) {
                exploreBtn.classList.remove('active');
                dailyBtn.classList.add('active');
                
                if (newGameBtn) {
                    newGameBtn.classList.add('disabled');
                    newGameBtn.title = 'New Game not available in Daily mode - switch to Explore mode';
                }
            } else {
                exploreBtn.classList.add('active');
                dailyBtn.classList.remove('active');
                
                if (newGameBtn) {
                    newGameBtn.classList.remove('disabled');
                    newGameBtn.title = '';
                }
            }
        }

        function handleNewGame() {
            if (gameState.isDailyMode) {
                alert('New Game is not available in Daily mode.\n\nSwitch to Explore mode if you want to start a new random challenge.');
                return;
            }
            
            localStorage.removeItem('wikipath_explore_start');
            localStorage.removeItem('wikipath_explore_target');
            
            startNewGame();
        }

        // ======================
        // WIKIPEDIA API
        // ======================
        // Prefetch cache for instant page loads
        const prefetchCache = new Map();
        const prefetchInProgress = new Set();
        const MAX_PREFETCH_CONCURRENT = 3;

        // localStorage cache configuration
        const CACHE_PREFIX = 'wikipath_cache_';
        const CACHE_EXPIRY = 60 * 60 * 1000; // 1 hour in milliseconds
        const MAX_CACHE_ENTRIES = 50;

        // Get page from localStorage cache
        function getFromCache(title) {
            try {
                const cacheKey = CACHE_PREFIX + title;
                const cached = localStorage.getItem(cacheKey);
                if (!cached) return null;

                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();

                // Check if expired
                if (now - timestamp > CACHE_EXPIRY) {
                    localStorage.removeItem(cacheKey);
                    return null;
                }

                console.log(`‚úì Using cached page: ${title}`);
                return data;
            } catch (error) {
                console.error('Error reading from cache:', error);
                return null;
            }
        }

        // Save page to localStorage cache
        function saveToCache(title, data) {
            try {
                const cacheKey = CACHE_PREFIX + title;
                const cacheEntry = {
                    data: data,
                    timestamp: Date.now()
                };

                localStorage.setItem(cacheKey, JSON.stringify(cacheEntry));

                // Clean up old entries if we exceed max
                cleanupCache();
            } catch (error) {
                // If storage is full, clear some old entries
                if (error.name === 'QuotaExceededError') {
                    console.log('Cache full, cleaning up...');
                    cleanupCache(true);
                }
            }
        }

        // Clean up old cache entries
        function cleanupCache(aggressive = false) {
            try {
                const cacheKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(CACHE_PREFIX)) {
                        cacheKeys.push(key);
                    }
                }

                // If we have too many entries or aggressive cleanup
                if (cacheKeys.length > MAX_CACHE_ENTRIES || aggressive) {
                    // Get all entries with timestamps
                    const entries = cacheKeys.map(key => {
                        try {
                            const { timestamp } = JSON.parse(localStorage.getItem(key));
                            return { key, timestamp };
                        } catch {
                            return { key, timestamp: 0 };
                        }
                    });

                    // Sort by timestamp (oldest first)
                    entries.sort((a, b) => a.timestamp - b.timestamp);

                    // Remove oldest entries
                    const toRemove = aggressive ? Math.ceil(entries.length / 2) : entries.length - MAX_CACHE_ENTRIES;
                    for (let i = 0; i < toRemove; i++) {
                        localStorage.removeItem(entries[i].key);
                    }
                }
            } catch (error) {
                console.error('Error cleaning cache:', error);
            }
        }

        async function fetchWikipediaPage(title) {
            // Check localStorage cache first
            const cachedPage = getFromCache(title);
            if (cachedPage) {
                return cachedPage;
            }

            // Check prefetch cache second
            if (prefetchCache.has(title)) {
                console.log(`‚úì Using prefetched page: ${title}`);
                const cached = prefetchCache.get(title);
                prefetchCache.delete(title); // Remove from cache after use

                // Save to localStorage for future use
                saveToCache(title, cached);

                return cached;
            }

            const endpoint = 'https://en.wikipedia.org/w/api.php';
            const params = new URLSearchParams({
                action: 'parse',
                page: title,
                format: 'json',
                origin: '*',
                prop: 'text|sections',
                disabletoc: '1',
                redirects: '1'
            });

            try {
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.info);
                }

                // Save to localStorage cache
                saveToCache(title, data.parse);

                return data.parse;
            } catch (error) {
                console.error('Error fetching Wikipedia page:', error);
                throw error;
            }
        }

        // Prefetch a page in the background
        async function prefetchPage(title) {
            // Don't prefetch if already in localStorage cache or in progress
            if (getFromCache(title) || prefetchCache.has(title) || prefetchInProgress.has(title)) {
                return;
            }

            // Limit concurrent prefetches
            if (prefetchInProgress.size >= MAX_PREFETCH_CONCURRENT) {
                return;
            }

            prefetchInProgress.add(title);
            console.log(`‚Üí Prefetching: ${title}`);

            try {
                const endpoint = 'https://en.wikipedia.org/w/api.php';
                const params = new URLSearchParams({
                    action: 'parse',
                    page: title,
                    format: 'json',
                    origin: '*',
                    prop: 'text|sections',
                    disabletoc: '1',
                    redirects: '1'
                });

                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.info);
                }

                // Store in both caches
                prefetchCache.set(title, data.parse);
                saveToCache(title, data.parse);
                console.log(`‚úì Prefetched: ${title}`);

                // Keep prefetch cache size reasonable (max 10 pages)
                if (prefetchCache.size > 10) {
                    const firstKey = prefetchCache.keys().next().value;
                    prefetchCache.delete(firstKey);
                }
            } catch (error) {
                console.log(`‚úó Prefetch failed: ${title}`, error);
            } finally {
                prefetchInProgress.delete(title);
            }
        }

        async function fetchPageDescription(title) {
            const endpoint = 'https://en.wikipedia.org/w/api.php';
            const params = new URLSearchParams({
                action: 'query',
                titles: title,
                format: 'json',
                origin: '*',
                prop: 'extracts',
                exintro: true,
                explaintext: true,
                exsentences: 2
            });

            try {
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                
                if (pageId === '-1') {
                    return '';
                }
                
                return pages[pageId].extract || '';
            } catch (error) {
                console.error('Error fetching page description:', error);
                return '';
            }
        }

        async function getRandomWikipediaPage() {
            const randomIndex = Math.floor(Math.random() * ALL_PAGES.length);
            return ALL_PAGES[randomIndex];
        }

        async function getDailyWikipediaPages() {
            const seed = dateToSeed(gameState.dailyDate);
            
            const startIndex = getSeededRandomIndex(ALL_PAGES, seed, 0);
            const startPage = ALL_PAGES[startIndex];
            
            let targetIndex;
            do {
                targetIndex = getSeededRandomIndex(ALL_PAGES, seed, 1000);
            } while (targetIndex === startIndex);
            const targetPage = ALL_PAGES[targetIndex];
            
            return { startPage, targetPage };
        }

        // ======================
        // HINT SYSTEM
        // ======================
        function showHint(currentPage) {
            const hintBadge = document.getElementById('hint-badge');
            const hintIcon = document.getElementById('hint-icon');
            const hintText = document.getElementById('hint-text');
            
            if (!hintBadge || !gameState.targetPage) return;
            
            const currentWords = currentPage.toLowerCase().split(/[\s_\-()]+/);
            const targetWords = gameState.targetPage.toLowerCase().split(/[\s_\-()]+/);
            
            const commonWords = currentWords.filter(word => 
                word.length > 3 && targetWords.includes(word)
            ).length;
            
            hintBadge.className = 'hint-badge active';
            
            if (commonWords >= 2) {
                hintBadge.classList.add('hot');
                hintIcon.textContent = 'üî•';
                hintText.textContent = "You're very close!";
            } else if (commonWords === 1) {
                hintBadge.classList.add('warmer');
                hintIcon.textContent = 'üå°Ô∏è';
                hintText.textContent = 'Getting warmer!';
            } else if (gameState.path.length > 5) {
                hintBadge.classList.add('colder');
                hintIcon.textContent = '‚ùÑÔ∏è';
                hintText.textContent = 'Try a different direction';
            } else {
                hintBadge.classList.add('warmer');
                hintIcon.textContent = 'üß≠';
                hintText.textContent = 'Keep exploring!';
            }
            
            setTimeout(() => {
                hintBadge.classList.remove('active');
            }, 3000);
        }

        // ======================
        // GAME CONTROLLER
        // ======================
        class GameController {
            constructor() {
                this.gameArea = document.getElementById('game-area');
                this.clickCounter = document.getElementById('click-counter');
                this.timerDisplay = document.getElementById('timer');
                this.targetPageDisplay = document.getElementById('target-page-display');
                this.tocContainer = document.getElementById('toc-list');
                this.timerInterval = null;
            }

            async initialize() {
                const urlParams = getUrlParams();
                
                if (urlParams.start && urlParams.target) {
                    if (urlParams.daily) {
                        gameState.isDailyMode = true;
                        gameState.dailyDate = urlParams.daily;
                        
                        if (urlParams.daily !== getTodayDateString()) {
                            gameState.dailyDate = getTodayDateString();
                            await this.startNewDailyChallenge();
                            return;
                        }
                    } else {
                        gameState.isDailyMode = false;
                    }
                    
                    gameState.startPage = urlParams.start;
                    gameState.targetPage = urlParams.target;
                    gameState.currentPage = urlParams.current || urlParams.start;
                    gameState.clickCount = urlParams.clicks;
                    gameState.totalClicks = urlParams.totalClicks;
                    gameState.visitedPages = new Set(urlParams.visited);
                    gameState.path = urlParams.path.length > 0 ? urlParams.path : [{ page: urlParams.start, isBacktrack: false }];
                    gameState.startTime = urlParams.startTime;
                    
                    updateModeUI();
                    
                    gameState.targetDescription = await fetchPageDescription(gameState.targetPage);
                    
                    this.updateDisplay();
                    this.updatePathDisplay();
                    this.startTimer();

                    // NEW: Calculate minimum clicks for resumed game
                    calculateMinimumClicks(gameState.startPage, gameState.targetPage);

                    // Initialize history state for back button
                    const state = {
                        start: gameState.startPage,
                        target: gameState.targetPage,
                        current: gameState.currentPage,
                        clicks: gameState.clickCount,
                        totalClicks: gameState.totalClicks,
                        visited: Array.from(gameState.visitedPages),
                        path: gameState.path,
                        startTime: gameState.startTime,
                        isDailyMode: gameState.isDailyMode,
                        dailyDate: gameState.dailyDate
                    };
                    window.history.replaceState(state, '', window.location.href);

                    await this.loadPage(gameState.currentPage);
                } else {
                    if (gameState.isDailyMode) {
                        await this.startNewDailyChallenge();
                    } else {
                        await this.startNewExploreGame();
                    }
                }
            }

            async startNewDailyChallenge() {
                const { startPage, targetPage } = await getDailyWikipediaPages();
                
                gameState.startPage = startPage;
                gameState.targetPage = targetPage;
                gameState.currentPage = startPage;
                gameState.clickCount = 0;
                gameState.totalClicks = 0;
                gameState.visitedPages = new Set([startPage]);
                gameState.path = [{ page: startPage, isBacktrack: false }];
                gameState.startTime = Date.now();
                gameState.hasWon = false;
                gameState.gaveUp = false;
                gameState.difficulty = calculateChallengeDifficulty(startPage, targetPage);
                
                updateModeUI();
                
                gameState.targetDescription = await fetchPageDescription(targetPage);
                
                this.updateDisplay();
                this.updatePathDisplay();
                this.startTimer();
                
                // NEW: Calculate minimum clicks
                calculateMinimumClicks(startPage, targetPage);
                
                updateUrl(
                    startPage,
                    targetPage,
                    startPage,
                    0,
                    0,
                    [startPage],
                    [{ page: startPage, isBacktrack: false }],
                    gameState.startTime
                );
                
                await this.loadPage(startPage);
            }

            async startNewExploreGame() {
                const startPage = await getRandomWikipediaPage();
                let targetPage;
                do {
                    targetPage = await getRandomWikipediaPage();
                } while (targetPage === startPage);

                gameState.startPage = startPage;
                gameState.targetPage = targetPage;
                gameState.currentPage = startPage;
                gameState.clickCount = 0;
                gameState.totalClicks = 0;
                gameState.visitedPages = new Set([startPage]);
                gameState.path = [{ page: startPage, isBacktrack: false }];
                gameState.startTime = Date.now();
                gameState.hasWon = false;
                gameState.gaveUp = false;
                gameState.difficulty = calculateChallengeDifficulty(startPage, targetPage);
                
                localStorage.setItem('wikipath_explore_start', startPage);
                localStorage.setItem('wikipath_explore_target', targetPage);

                updateModeUI();

                gameState.targetDescription = await fetchPageDescription(targetPage);

                this.updateDisplay();
                this.updatePathDisplay();
                this.startTimer();

                // NEW: Calculate minimum clicks
                calculateMinimumClicks(startPage, targetPage);

                updateUrl(
                    startPage,
                    targetPage,
                    startPage,
                    0,
                    0,
                    [startPage],
                    [{ page: startPage, isBacktrack: false }],
                    gameState.startTime
                );

                await this.loadPage(startPage);
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    const elapsed = Date.now() - gameState.startTime;
                    const seconds = Math.floor(elapsed / 1000);
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    this.timerDisplay.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
            }

            updatePathDisplay() {
                // Update side panel timeline
                const pathTimeline = document.getElementById('path-timeline');
                pathTimeline.innerHTML = '';

                // Update breadcrumb bar - centered single container
                const pathBreadcrumb = document.getElementById('path-breadcrumb');
                pathBreadcrumb.innerHTML = '';

                // Calculate if we need to collapse based on estimated width
                // Rough estimate: each step ~120px, arrow ~20px, collapse ~100px
                const pathBar = document.getElementById('path-bar');
                const COLLAPSE_MARGIN = 200; // 200px buffer on each side before collapsing
                const availableWidth = pathBar ? pathBar.clientWidth - 40 - (COLLAPSE_MARGIN * 2) : 1000; // 40px padding + margin buffer
                const estimatedStepWidth = 120;
                const estimatedArrowWidth = 20;
                const estimatedWidth = (gameState.path.length * estimatedStepWidth) + ((gameState.path.length - 1) * estimatedArrowWidth) + 150; // +150 for target
                const shouldCollapse = estimatedWidth > availableWidth;

                // Build list of steps to show
                const stepsToShow = [];
                const currentIndex = gameState.path.length - 1;
                const collapsedSteps = []; // Track collapsed steps for tooltip

                gameState.path.forEach((pathItem, index) => {
                    const pageName = typeof pathItem === 'string' ? pathItem : pathItem.page;
                    const isBacktrack = typeof pathItem === 'object' && pathItem.isBacktrack;
                    const hintUsed = typeof pathItem === 'object' && pathItem.hintUsed;

                    // Side panel timeline item
                    const item = document.createElement('div');
                    item.className = 'path-timeline-item';
                    if (index === gameState.path.length - 1) {
                        item.classList.add('current');
                    }
                    if (isBacktrack) {
                        item.classList.add('backtrack');
                    }

                    item.innerHTML = `
                        <div class="path-item-number">Step ${index + 1}</div>
                        <div class="path-item-title">${pageName}${isBacktrack ? ' ‚Ü©Ô∏è' : ''}${hintUsed ? ' üí°' : ''}</div>
                    `;

                    pathTimeline.appendChild(item);

                    // Breadcrumb logic: always show Start + Current + Target when collapsing
                    const isCurrent = index === currentIndex;
                    const isStart = index === 0;
                    const isTarget = pageName === gameState.targetPage;

                    if (!shouldCollapse || isStart || isCurrent || isTarget) {
                        stepsToShow.push({index, pageName, isBacktrack, hintUsed, isCurrent, isStart, isTarget});
                    } else {
                        collapsedSteps.push({index, pageName, isBacktrack, hintUsed});
                    }
                });

                // Build breadcrumb
                let lastShownIndex = -1;
                stepsToShow.forEach((stepData, arrayIndex) => {
                    const {index, pageName, isBacktrack, hintUsed, isCurrent, isStart, isTarget} = stepData;

                    // Check if there are hidden steps between this and last shown
                    const hiddenSteps = collapsedSteps.filter(cs => cs.index > lastShownIndex && cs.index < index);

                    if (hiddenSteps.length > 0 && arrayIndex > 0) {
                        // Add collapse indicator
                        const arrow = document.createElement('span');
                        arrow.className = 'path-arrow';
                        arrow.textContent = '‚Üí';
                        pathBreadcrumb.appendChild(arrow);

                        const collapse = document.createElement('div');
                        collapse.className = 'path-collapse';
                        collapse.textContent = `... ${hiddenSteps.length} more ...`;

                        // Create tooltip with hidden step names
                        const tooltip = document.createElement('div');
                        tooltip.className = 'path-collapse-tooltip';
                        tooltip.innerHTML = hiddenSteps.map(hs => `${hs.index + 1}. ${hs.pageName}${hs.hintUsed ? ' üí°' : ''}${hs.isBacktrack ? ' ‚Ü©Ô∏è' : ''}`).join('<br>');
                        collapse.appendChild(tooltip);

                        pathBreadcrumb.appendChild(collapse);
                    }

                    // Add arrow before step (except for the first step)
                    if (arrayIndex > 0 && hiddenSteps.length === 0) {
                        const arrow = document.createElement('span');
                        arrow.className = 'path-arrow';
                        arrow.textContent = '‚Üí';
                        pathBreadcrumb.appendChild(arrow);
                    }

                    const step = document.createElement('div');
                    step.className = 'path-step';

                    if (isCurrent) {
                        step.classList.add('current');
                    }

                    if (isStart) {
                        step.classList.add('start');
                    }

                    if (isTarget) {
                        step.classList.add('target');
                    }

                    if (isBacktrack) {
                        step.classList.add('backtrack');
                    }

                    if (hintUsed) {
                        step.classList.add('hint-used');
                    }

                    // Truncate long page names for breadcrumb
                    const shortName = pageName.length > 20 ? pageName.substring(0, 20) + '...' : pageName;

                    step.innerHTML = `
                        <span class="step-number">${index + 1}.</span>
                        <span>${shortName}${isBacktrack ? ' ‚Ü©Ô∏è' : ''}</span>
                    `;
                    step.title = pageName; // Full name on hover

                    pathBreadcrumb.appendChild(step);
                    lastShownIndex = index;
                });

                // Always add target page indicator at the end if not reached yet
                if (gameState.targetPage && !gameState.path.some(p => {
                    const name = typeof p === 'string' ? p : p.page;
                    return name === gameState.targetPage;
                })) {
                    const arrow = document.createElement('span');
                    arrow.className = 'path-arrow';
                    arrow.textContent = '‚Üí';
                    pathBreadcrumb.appendChild(arrow);

                    const targetStep = document.createElement('div');
                    targetStep.className = 'path-step target-indicator';
                    const shortTargetName = gameState.targetPage.length > 20
                        ? gameState.targetPage.substring(0, 20) + '...'
                        : gameState.targetPage;
                    targetStep.innerHTML = `<span>${shortTargetName}</span>`;
                    targetStep.title = gameState.targetPage + ' (Target)';
                    pathBreadcrumb.appendChild(targetStep);
                }
            }

            async loadPage(title) {
                // Normalize title: replace underscores with spaces for consistency
                title = title.replace(/_/g, ' ');

                // Start progress bar
                showProgressBar();

                // Show skeleton screen
                this.gameArea.innerHTML = `
                    <div class="skeleton-container">
                        <div class="skeleton skeleton-infobox"></div>
                        <div class="skeleton skeleton-title"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-paragraph medium"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-paragraph short"></div>
                        <div class="skeleton skeleton-paragraph medium"></div>
                        <div class="skeleton skeleton-heading"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-paragraph medium"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-paragraph short"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-heading"></div>
                        <div class="skeleton skeleton-paragraph medium"></div>
                        <div class="skeleton skeleton-paragraph"></div>
                        <div class="skeleton skeleton-paragraph short"></div>
                    </div>
                `;
                this.tocContainer.innerHTML = '';

                try {
                    const pageData = await fetchWikipediaPage(title);

                    // Complete progress bar
                    completeProgressBar();
                    
                    const actualPageTitle = pageData.title;
                    
                    if (actualPageTitle !== title) {
                        console.log(`Redirect: ${title} -> ${actualPageTitle}`);
                        gameState.currentPage = actualPageTitle;

                        if (gameState.path[gameState.path.length - 1].page === title) {
                            gameState.path[gameState.path.length - 1].page = actualPageTitle;
                        }

                        // Use replaceState instead of pushState for redirects
                        const params = new URLSearchParams();
                        params.set('start', gameState.startPage);
                        params.set('target', gameState.targetPage);
                        params.set('current', gameState.currentPage);
                        params.set('clicks', gameState.clickCount);
                        params.set('totalClicks', gameState.totalClicks);
                        params.set('visited', Array.from(gameState.visitedPages).join(','));
                        params.set('path', JSON.stringify(gameState.path));
                        params.set('startTime', gameState.startTime);

                        if (gameState.isDailyMode) {
                            params.set('daily', gameState.dailyDate);
                        }

                        const newUrl = `${window.location.pathname}?${params.toString()}`;
                        const state = {
                            start: gameState.startPage,
                            target: gameState.targetPage,
                            current: gameState.currentPage,
                            clicks: gameState.clickCount,
                            totalClicks: gameState.totalClicks,
                            visited: Array.from(gameState.visitedPages),
                            path: gameState.path,
                            startTime: gameState.startTime,
                            isDailyMode: gameState.isDailyMode,
                            dailyDate: gameState.dailyDate
                        };

                        console.log('Replacing state for redirect:', newUrl);
                        window.history.replaceState(state, '', newUrl);
                        
                        const normalizedCurrent = actualPageTitle.trim().toLowerCase().replace(/_/g, ' ');
                        const normalizedTarget = gameState.targetPage.trim().toLowerCase().replace(/_/g, ' ');
                        
                        if (normalizedCurrent === normalizedTarget) {
                            this.showWinScreen();
                            return;
                        }
                    }
                    
                    this.renderPage(pageData);
                    this.buildTableOfContents(pageData.sections);
                } catch (error) {
                    // Complete progress bar even on error
                    completeProgressBar();
                    this.showError(`Failed to load page: ${error.message}`);
                }
            }

            buildTableOfContents(sections) {
                if (!sections || sections.length === 0) {
                    this.tocContainer.innerHTML = '<li style="color: #777; font-size: 0.9em;">No sections available</li>';
                    return;
                }

                this.tocContainer.innerHTML = '';

                // Filter out "External links" and other unwanted sections from TOC
                const filteredSections = sections.filter(section => {
                    const title = section.line.toLowerCase();
                    return !title.includes('external link');
                });

                const sectionGroups = {};
                let currentH1 = null;

                filteredSections.forEach(section => {
                    if (section.toclevel === 1) {
                        currentH1 = section.line;
                        sectionGroups[currentH1] = {
                            header: section,
                            subsections: []
                        };
                    } else if (section.toclevel === 2 && currentH1) {
                        sectionGroups[currentH1].subsections.push(section);
                    }
                });
                
                Object.entries(sectionGroups).forEach(([h1Title, group]) => {
                    const li = document.createElement('li');
                    li.className = 'toc-item';
                    
                    const hasSubsections = group.subsections.length > 0;
                    
                    const header = document.createElement('div');
                    header.className = hasSubsections ? 'toc-section-header collapsed' : 'toc-section-header no-children';
                    
                    if (hasSubsections) {
                        header.innerHTML = `
                            <span class="toc-collapse-icon">‚ñº</span>
                            <span>${h1Title}</span>
                        `;
                    } else {
                        header.innerHTML = `<span>${h1Title}</span>`;
                    }
                    
                    const subsectionsList = document.createElement('ul');
                    subsectionsList.className = 'toc-subsections collapsed';
                    
                    header.addEventListener('click', (e) => {
                        if (hasSubsections) {
                            header.classList.toggle('collapsed');
                            subsectionsList.classList.toggle('collapsed');
                        }
                        
                        const heading = document.getElementById(group.header.anchor);
                        if (heading) {
                            heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                    
                    group.subsections.forEach(subsection => {
                        const subLi = document.createElement('li');
                        subLi.className = 'toc-item';
                        
                        const link = document.createElement('a');
                        link.className = 'toc-link';
                        link.textContent = subsection.line;
                        
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const heading = document.getElementById(subsection.anchor);
                            if (heading) {
                                heading.scrollIntoView({ behavior: 'smooth', block: 'start' });

                                document.querySelectorAll('.toc-link').forEach(l => l.classList.remove('active'));
                                link.classList.add('active');
                            }
                        });
                        
                        subLi.appendChild(link);
                        subsectionsList.appendChild(subLi);
                    });
                    
                    li.appendChild(header);
                    if (hasSubsections) {
                        li.appendChild(subsectionsList);
                    }
                    this.tocContainer.appendChild(li);
                });
            }

            renderPage(pageData) {
                const articleDiv = document.createElement('div');
                articleDiv.className = 'wikipedia-article';
                
                let htmlContent = pageData.text['*'];
                
                htmlContent = htmlContent.replace(/src="\/\//g, 'src="https://');
                htmlContent = htmlContent.replace(/srcset="\/\//g, 'srcset="https://');
                htmlContent = htmlContent.replace(/src="\/(?!\/)/g, 'src="https://en.wikipedia.org/');
                htmlContent = htmlContent.replace(/srcset="\/(?!\/)/g, 'srcset="https://en.wikipedia.org/');
                
                articleDiv.innerHTML = htmlContent;

                // DEBUG: Check what images we have
                const imageCount = articleDiv.querySelectorAll('img').length;
                console.log(`HTML loaded with ${imageCount} images`);
                if (imageCount > 0) {
                    const firstImg = articleDiv.querySelector('img');
                    console.log('First image src:', firstImg?.getAttribute('src'));
                    console.log('First image srcset:', firstImg?.getAttribute('srcset'));
                }

                // Remove notification boxes but BE CAREFUL not to remove images
                // Only remove elements that DON'T contain images
                articleDiv.querySelectorAll('.ambox, .hatnote, .dablink, .rellink').forEach(el => {
                    if (!el.querySelector('img')) {
                        el.remove();
                    }
                });
                articleDiv.querySelectorAll('.hatnote, [class*="hatnote"]').forEach(el => {
                    if (!el.querySelector('img')) {
                        el.remove();
                    }
                });
                // Edit section links are safe to remove (they never contain images)
                articleDiv.querySelectorAll('.mw-editsection, [class*="editsection"]').forEach(el => el.remove());

                // Remove external videos/media boxes - check by content and common classes
                articleDiv.querySelectorAll('.side-box, .sister-external, [class*="external"]').forEach(el => {
                    const text = el.textContent.toLowerCase();
                    if (text.includes('external video') || text.includes('external media') || text.includes('external link')) {
                        el.remove();
                    }
                });

                // Remove any table/box with "External videos", "External media", "External links" headers
                articleDiv.querySelectorAll('table, div[class*="box"]').forEach(box => {
                    const allHeaders = box.querySelectorAll('th, caption, .infobox-header, [class*="header"]');
                    const headerTexts = Array.from(allHeaders).map(h => h.textContent.toLowerCase().trim());

                    // Check if any header is explicitly about external content
                    const isExternalBox = headerTexts.some(h =>
                        h === 'external videos' || h === 'external video' ||
                        h === 'external media' || h === 'external links' ||
                        h === 'external images' || h === 'images' || h === 'video'
                    );

                    if (isExternalBox) {
                        const text = box.textContent.toLowerCase();
                        const hasSubstantiveContent =
                            text.includes('born') || text.includes('died') || text.includes('population') ||
                            text.includes('founded') || text.includes('location') || text.includes('capital') ||
                            text.includes('area') || text.includes('president');

                        // If it's external content with no substantive info, remove it
                        if (!hasSubstantiveContent) {
                            box.remove();
                        }
                    }
                });

                // Remove "External links" sections (usually at the end of articles)
                articleDiv.querySelectorAll('h2, h3').forEach(heading => {
                    const headingText = heading.textContent.toLowerCase().trim();

                    // Match "external links" or "external link" (use includes for flexibility)
                    if (headingText.includes('external link')) {
                        // Find the wrapper (could be .mw-heading or direct parent)
                        let sectionStart = heading.parentElement?.classList.contains('mw-heading') ?
                                          heading.parentElement : heading;

                        const elementsToRemove = [sectionStart];

                        // Collect all siblings until next heading section
                        let nextSibling = sectionStart.nextElementSibling;
                        while (nextSibling) {
                            // Stop if we hit another heading section
                            if (nextSibling.classList.contains('mw-heading') ||
                                nextSibling.querySelector('h2, h3')) {
                                break;
                            }
                            elementsToRemove.push(nextSibling);
                            nextSibling = nextSibling.nextElementSibling;
                        }

                        // External links sections are never useful for the game - always remove them
                        elementsToRemove.forEach(el => el.remove());
                    }
                });

                console.log(`After cleanup: ${articleDiv.querySelectorAll('img').length} images remaining`);
                
                if (gameState.currentPage === gameState.startPage && gameState.path.length === 1) {
                    const indicator = document.createElement('div');
                    indicator.className = 'starting-page-indicator';
                    indicator.innerHTML = `
                        <div class="icon">üöÄ</div>
                        <div class="text">
                            <div class="label">Starting Point</div>
                            <div class="description">Your journey begins here. Find your way to "<strong>${gameState.targetPage}</strong>" by following the links.</div>
                        </div>
                    `;
                    
                    const firstElement = articleDiv.firstElementChild;
                    if (firstElement) {
                        articleDiv.insertBefore(indicator, firstElement);
                    } else {
                        articleDiv.appendChild(indicator);
                    }
                }
                
                let h1 = articleDiv.querySelector('h1');
                if (!h1) {
                    h1 = document.createElement('h1');
                    h1.textContent = pageData.title;
                    
                    const startingIndicator = articleDiv.querySelector('.starting-page-indicator');
                    if (startingIndicator && startingIndicator.nextSibling) {
                        articleDiv.insertBefore(h1, startingIndicator.nextSibling);
                    } else if (startingIndicator) {
                        articleDiv.appendChild(h1);
                    } else {
                        const firstElement = articleDiv.firstElementChild;
                        if (firstElement) {
                            articleDiv.insertBefore(h1, firstElement);
                        } else {
                            articleDiv.appendChild(h1);
                        }
                    }
                }
                
                const noticesContainer = document.createElement('div');
                noticesContainer.className = 'article-notices-container';
                
                const hasVerificationIssue = 
                    pageData.text['*'].includes('This article needs additional citations') ||
                    pageData.text['*'].includes('needs additional verification') ||
                    pageData.text['*'].includes('lacks sufficient inline citations') ||
                    pageData.text['*'].includes('cite check') ||
                    (pageData.text['*'].includes('ambox-content') && pageData.text['*'].includes('citation'));
                
                if (hasVerificationIssue) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice verification';
                    notice.textContent = '‚ö†Ô∏è';
                    notice.setAttribute('data-tooltip', 'This article may need additional verification');
                    noticesContainer.appendChild(notice);
                }
                
                if (pageData.text['*'].includes('current event') || pageData.text['*'].includes('recently updated')) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice recent-changes';
                    notice.textContent = 'üìù';
                    notice.setAttribute('data-tooltip', 'This article has been recently updated');
                    noticesContainer.appendChild(notice);
                }
                
                if (pageData.text['*'].includes('recently died') || pageData.text['*'].includes('recent death')) {
                    const notice = document.createElement('span');
                    notice.className = 'article-notice recent-death';
                    notice.textContent = 'üïäÔ∏è';
                    notice.setAttribute('data-tooltip', 'Subject recently deceased');
                    noticesContainer.appendChild(notice);
                }
                
                if (noticesContainer.children.length > 0 && h1) {
                    const h1Container = document.createElement('div');
                    h1Container.style.position = 'relative';
                    
                    const h1Parent = h1.parentNode;
                    h1Parent.insertBefore(h1Container, h1);
                    h1Container.appendChild(h1);
                    h1Container.appendChild(noticesContainer);
                }

                this.gameArea.innerHTML = '';
                this.gameArea.appendChild(articleDiv);

                // Clear any remaining loading states from previous page
                document.querySelectorAll('.wikipedia-article a.loading').forEach(link => {
                    link.classList.remove('loading');
                });

                this.processLinks();
                this.fixImages();
                this.makeCollapsibleSections();
            }

            makeCollapsibleSections() {
                const isMobile = window.innerWidth <= 768;
                console.log('=== Making Collapsible Sections (WRAPPER FIX) ===');
                console.log('Is mobile:', isMobile, 'Window width:', window.innerWidth);
                
                // Find all H2 headers
                const headers = Array.from(this.gameArea.querySelectorAll('h2'));
                console.log('Found H2 headers:', headers.length);
                
                if (headers.length === 0) {
                    console.log('No headers found');
                    return;
                }
                
                headers.forEach((header, index) => {
                    console.log(`\nProcessing: "${header.textContent.trim()}"`);
                    
                    // Skip if already processed
                    if (header.querySelector('.section-toggle')) {
                        console.log('  Already processed');
                        return;
                    }
                    
                    // Find the mw-heading wrapper div that contains this H2
                    let headerWrapper = header.closest('.mw-heading');
                    if (!headerWrapper) {
                        console.log('  No mw-heading wrapper found, using H2 directly');
                        headerWrapper = header;
                    }
                    
                    console.log('  Header wrapper:', headerWrapper.className);
                    
                    // Find next H2's wrapper
                    const nextHeader = headers[index + 1];
                    let nextHeaderWrapper = null;
                    if (nextHeader) {
                        nextHeaderWrapper = nextHeader.closest('.mw-heading') || nextHeader;
                    }
                    
                    // Collect all siblings between this wrapper and the next
                    const contentElements = [];
                    let currentElement = headerWrapper.nextElementSibling;
                    
                    while (currentElement) {
                        // Stop if we hit the next header's wrapper
                        if (currentElement === nextHeaderWrapper) {
                            break;
                        }
                        
                        // Stop if this element contains the next header
                        if (nextHeader && currentElement.contains(nextHeader)) {
                            break;
                        }
                        
                        // Skip other mw-heading divs (subsections like H3, H4)
                        if (currentElement.classList && currentElement.classList.contains('mw-heading')) {
                            // This is a subsection, but we still want to include it
                            contentElements.push(currentElement);
                        } else {
                            contentElements.push(currentElement);
                        }
                        
                        currentElement = currentElement.nextElementSibling;
                    }
                    
                    console.log(`  Content elements found: ${contentElements.length}`);
                    
                    if (contentElements.length === 0) {
                        console.log('  No content');
                        return;
                    }
                    
                    // Create wrapper
                    const wrapper = document.createElement('div');
                    wrapper.className = 'section-content';
                    
                    // Move content into wrapper
                    contentElements.forEach(el => {
                        wrapper.appendChild(el);
                    });
                    
                    // Insert wrapper after the header wrapper
                    headerWrapper.parentNode.insertBefore(wrapper, headerWrapper.nextSibling);

                    // Add toggle button to the actual H2
                    const toggleBtn = document.createElement('span');
                    toggleBtn.className = 'section-toggle';
                    toggleBtn.textContent = '[-]';
                    toggleBtn.setAttribute('role', 'button');
                    toggleBtn.setAttribute('aria-label', 'Expand or collapse section');
                    toggleBtn.setAttribute('tabindex', '0');

                    // Make toggle button large and prevent scroll on it
                    toggleBtn.style.display = 'inline-flex';
                    toggleBtn.style.alignItems = 'center';
                    toggleBtn.style.justifyContent = 'center';
                    toggleBtn.style.minWidth = '44px';
                    toggleBtn.style.minHeight = '44px';
                    toggleBtn.style.cursor = 'pointer';
                    toggleBtn.style.userSelect = 'none';
                    toggleBtn.style.webkitUserSelect = 'none';
                    toggleBtn.style.touchAction = 'manipulation'; // Prevent double-tap zoom and scrolling
                    toggleBtn.style.marginRight = '8px';
                    toggleBtn.style.verticalAlign = 'middle'; // Align button lower

                    header.insertBefore(toggleBtn, header.firstChild);
                    header.setAttribute('aria-expanded', 'true');
                    header.style.cursor = 'pointer'; // Make header clickable again

                    // Store references
                    header._collapsibleWrapper = wrapper;
                    header._collapsibleToggle = toggleBtn;
                    
                    // Should collapse?
                    const shouldCollapse = isMobile || this.shouldCollapseSection(header);
                    
                    if (shouldCollapse) {
                        wrapper.style.display = 'none';
                        toggleBtn.textContent = '[+]';
                        console.log('  ‚úì COLLAPSED');
                    } else {
                        console.log('  ‚úì Expanded');
                    }
                    
                    // Track if user manually toggled this section
                    let userToggled = false;

                    // SIMPLE toggle - just click the button
                    const toggle = (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const isVisible = wrapper.style.display !== 'none';

                        if (isVisible) {
                            wrapper.style.display = 'none';
                            toggleBtn.textContent = '[+]';
                            header.setAttribute('aria-expanded', 'false');
                            console.log('Section COLLAPSED by user');
                        } else {
                            wrapper.style.display = 'block';
                            toggleBtn.textContent = '[-]';
                            header.setAttribute('aria-expanded', 'true');
                            console.log('Section EXPANDED by user');
                        }

                        // Mark that user manually toggled this
                        userToggled = true;
                        header._userToggled = true;
                    };

                    // Make entire header clickable
                    header.addEventListener('click', toggle);

                    // Keyboard support
                    header.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            toggle(e);
                        }
                    });

                    // Store reference for hint feature to expand section if needed
                    header._collapsibleSection = { wrapper, toggleBtn, toggle };
                });
                
                console.log('=== Complete ===');
            }
            
            updateCollapsibleSectionsForResize() {
                // Update section states based on current window width
                const isMobile = window.innerWidth <= 768;
                console.log('=== Updating sections for resize ===');
                console.log('Window width:', window.innerWidth, 'Is mobile:', isMobile);

                const headers = this.gameArea.querySelectorAll('h2');

                headers.forEach(header => {
                    const wrapper = header._collapsibleWrapper;
                    const toggleBtn = header._collapsibleToggle;

                    if (!wrapper || !toggleBtn) return;

                    // NEVER change state if user manually toggled this section
                    if (header._userToggled) {
                        console.log('Skipping - user manually toggled this section');
                        return;
                    }

                    // Check if section should be collapsed
                    const shouldCollapse = isMobile || this.shouldCollapseSection(header);

                    // Only auto-collapse/expand if user hasn't manually toggled
                    // Check if current state matches what it should be
                    const isCurrentlyCollapsed = wrapper.style.display === 'none';

                    if (shouldCollapse && !isCurrentlyCollapsed) {
                        // Should be collapsed but isn't
                        wrapper.style.display = 'none';
                        toggleBtn.textContent = '[+]';
                    } else if (!shouldCollapse && isCurrentlyCollapsed && !this.shouldCollapseSection(header)) {
                        // Should be expanded but isn't (and it's not a special section)
                        wrapper.style.display = 'block';
                        toggleBtn.textContent = '[-]';
                    }
                });
            }
            
            shouldCollapseSection(header) {
                // Get clean header text without toggle button
                const headerText = header.textContent.replace(/\[\+\]|\[\-\]/g, '').toLowerCase().trim();
                
                // Sections to collapse by default
                const collapseKeywords = [
                    'royal titulary',
                    'titulary', 
                    'see also', 
                    'notes', 
                    'references',
                    'citations',
                    'bibliography',
                    'external links', 
                    'further reading',
                    'sources'
                ];
                
                return collapseKeywords.some(keyword => headerText.includes(keyword));
            }

            fixImages() {
                const images = this.gameArea.querySelectorAll('img');
                console.log(`Processing ${images.length} images...`);
                
                images.forEach((img, index) => {
                    // Add lazy loading for better performance
                    if (!img.hasAttribute('loading')) {
                        img.setAttribute('loading', 'lazy');
                    }
                    
                    // Handle images that still need fixing (edge cases)
                    const src = img.getAttribute('src');
                    if (src && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('//')) {
                        // This shouldn't happen if renderPage worked correctly, but just in case
                        img.setAttribute('src', 'https://en.wikipedia.org/' + src);
                        console.log(`Fixed edge case image ${index}: ${src}`);
                    }
                    
                    // Handle load errors
                    img.onerror = function() {
                        console.warn(`Image failed to load: ${this.src}`);
                        
                        // For Wikipedia images, show a placeholder
                        if (this.src.includes('upload.wikimedia.org') || this.src.includes('wikipedia.org')) {
                            this.style.display = 'none'; // Just hide broken Wikipedia images
                        } else {
                            this.style.display = 'none';
                        }
                    };
                    
                    img.onload = function() {
                        console.log(`‚úì Image ${index} loaded: ${this.src.substring(0, 80)}...`);
                    };
                });
                
                console.log('Image processing complete');
            }

            processLinks() {
                const links = this.gameArea.querySelectorAll('a');
                
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    
                    if (href && href.startsWith('/wiki/') && !href.includes(':')) {
                        let pageTitle;
                        try {
                            pageTitle = decodeURIComponent(href.replace('/wiki/', ''));
                        } catch (e) {
                            // If decoding fails (malformed URI), use the raw title
                            console.warn('Failed to decode URI:', href, e);
                            pageTitle = href.replace('/wiki/', '');
                        }

                        // Normalize page title: replace underscores with spaces for consistency
                        pageTitle = pageTitle.replace(/_/g, ' ');

                        // Store pageTitle as data attribute for later reference (e.g., for hints)
                        link.setAttribute('data-page-title', pageTitle);
                        
                        link.removeAttribute('href');
                        link.style.cursor = 'pointer';
                        
                        if (gameState.visitedPages.has(pageTitle)) {
                            link.classList.add('visited-link');
                        }
                        
                        if (pageTitle.includes('(disambiguation)') || 
                            link.textContent.toLowerCase().includes('disambiguation')) {
                            link.classList.add('disambiguation-link');
                        }
                        
                        let previewTimeout = null;
                        let prefetchTimeout = null;
                        let previewCache = {};

                        link.addEventListener('mouseenter', async (e) => {
                            // Start prefetch after 200ms (intent signal)
                            prefetchTimeout = setTimeout(() => {
                                prefetchPage(pageTitle);
                            }, 200);

                            // Show preview after 500ms (existing behavior)
                            previewTimeout = setTimeout(async () => {
                                const preview = document.getElementById('link-preview');
                                const previewTitle = document.getElementById('preview-title');
                                const previewText = document.getElementById('preview-text');

                                previewTitle.textContent = pageTitle;
                                previewText.innerHTML = '<span class="link-preview-loading">Loading preview...</span>';
                                preview.classList.add('active');

                                if (!previewCache[pageTitle]) {
                                    try {
                                        const description = await fetchPageDescription(pageTitle);
                                        previewCache[pageTitle] = description || 'No preview available.';
                                    } catch (error) {
                                        previewCache[pageTitle] = 'Preview unavailable.';
                                    }
                                }

                                if (preview.classList.contains('active')) {
                                    previewText.textContent = previewCache[pageTitle].substring(0, 200) + '...';
                                }
                            }, 500);
                        });
                        
                        link.addEventListener('mousemove', (e) => {
                            const preview = document.getElementById('link-preview');
                            if (preview.classList.contains('active')) {
                                let left = e.clientX + 15;
                                let top = e.clientY + 15;
                                
                                if (left + 350 > window.innerWidth) {
                                    left = e.clientX - 365;
                                }
                                if (top + preview.offsetHeight > window.innerHeight) {
                                    top = e.clientY - preview.offsetHeight - 15;
                                }
                                
                                preview.style.left = left + 'px';
                                preview.style.top = top + 'px';
                            }
                        });
                        
                        link.addEventListener('mouseleave', () => {
                            clearTimeout(previewTimeout);
                            clearTimeout(prefetchTimeout);
                            const preview = document.getElementById('link-preview');
                            preview.classList.remove('active');
                        });
                        
                        // Touch handling for links
                        let linkTouchStartY = 0;
                        let linkTouchStartX = 0;
                        let linkTouchStartTime = 0;
                        let linkTouchMoved = false;

                        link.addEventListener('touchstart', (e) => {
                            linkTouchStartY = e.touches[0].clientY;
                            linkTouchStartX = e.touches[0].clientX;
                            linkTouchStartTime = Date.now();
                            linkTouchMoved = false;
                            link.classList.add('touch-active');
                        }, { passive: true });

                        link.addEventListener('touchmove', (e) => {
                            const touchY = e.touches[0].clientY;
                            const touchX = e.touches[0].clientX;
                            const distanceY = Math.abs(touchY - linkTouchStartY);
                            const distanceX = Math.abs(touchX - linkTouchStartX);

                            if (distanceY > 10 || distanceX > 10) {
                                linkTouchMoved = true;
                                link.classList.remove('touch-active');
                            }
                        }, { passive: true });

                        link.addEventListener('touchend', async (e) => {
                            const touchEndY = e.changedTouches[0].clientY;
                            const touchEndX = e.changedTouches[0].clientX;
                            const touchDuration = Date.now() - linkTouchStartTime;
                            const distanceY = Math.abs(touchEndY - linkTouchStartY);
                            const distanceX = Math.abs(touchEndX - linkTouchStartX);
                            const totalDistance = Math.sqrt(distanceY * distanceY + distanceX * distanceX);

                            link.classList.remove('touch-active');

                            if (!linkTouchMoved && totalDistance < 10 && touchDuration < 500) {
                                e.preventDefault();
                                createRipple(link, e.changedTouches[0].clientX, e.changedTouches[0].clientY);

                                addClickFeedback(link);
                                link.classList.add('loading');

                                const preview = document.getElementById('link-preview');
                                preview.classList.remove('active');

                                if (link.classList.contains('disambiguation-link')) {
                                    const confirmed = confirm(`‚ö†Ô∏è WARNING: "${pageTitle}" appears to be a disambiguation page.\n\nDisambiguation pages don't contain actual content - they just list links to other articles with similar names.\n\nDo you want to continue?`);

                                    if (!confirmed) {
                                        link.classList.remove('loading');
                                        return;
                                    }
                                }

                                this.handleLinkClick(pageTitle);
                            }
                        }, { passive: false });

                        link.addEventListener('touchcancel', (e) => {
                            link.classList.remove('touch-active');
                            linkTouchMoved = false;
                        }, { passive: true });

                        // Desktop click handler
                        link.addEventListener('click', async (e) => {
                            // Ignore if this came from touch (we handle that separately)
                            if (e.pointerType === 'touch') return;

                            e.preventDefault();

                            addClickFeedback(link);

                            // Add loading state
                            link.classList.add('loading');

                            const preview = document.getElementById('link-preview');
                            preview.classList.remove('active');

                            if (link.classList.contains('disambiguation-link')) {
                                const confirmed = confirm(`‚ö†Ô∏è WARNING: "${pageTitle}" appears to be a disambiguation page.\n\nDisambiguation pages don't contain actual content - they just list links to other articles with similar names.\n\nDo you want to continue?`);

                                if (!confirmed) {
                                    // Remove loading state if user cancels
                                    link.classList.remove('loading');
                                    return;
                                }
                            }

                            this.handleLinkClick(pageTitle);
                        });
                    } else {
                        // For non-article links (like File: links), preserve any images they contain
                        const containsImage = link.querySelector('img');
                        if (containsImage) {
                            // Unwrap the image from the link but keep the image
                            link.parentNode.insertBefore(containsImage, link);
                            link.remove();
                        } else {
                            // Remove non-article links that don't contain images
                            link.remove();
                        }
                    }
                });
            }

            async handleLinkClick(pageTitle) {
                console.log('üëÜ handleLinkClick called for:', pageTitle);
                window.scrollTo({ top: 0, behavior: 'smooth' });

                const isNewPage = !gameState.visitedPages.has(pageTitle);
                const isBacktrack = !isNewPage; // It's a backtrack if we've visited this page before

                if (isNewPage) {
                    gameState.totalClicks++;
                    gameState.visitedPages.add(pageTitle);
                }

                gameState.clickCount++;
                gameState.currentPage = pageTitle;
                gameState.path.push({ page: pageTitle, isBacktrack: isBacktrack });
                
                showHint(pageTitle);
                
                updateUrl(
                    gameState.startPage,
                    gameState.targetPage,
                    gameState.currentPage,
                    gameState.clickCount,
                    gameState.totalClicks,
                    Array.from(gameState.visitedPages),
                    gameState.path,
                    gameState.startTime
                );
                
                this.updateDisplay();
                this.updatePathDisplay();

                const normalizedCurrent = pageTitle.trim().toLowerCase().replace(/_/g, ' ');
                const normalizedTarget = gameState.targetPage.trim().toLowerCase().replace(/_/g, ' ');
                
                if (normalizedCurrent === normalizedTarget) {
                    this.showWinScreen();
                    return;
                }

                await this.loadPage(pageTitle);
            }

            updateDisplay() {
                this.clickCounter.textContent = gameState.totalClicks;
                this.targetPageDisplay.textContent = gameState.targetPage;
                
                const difficultyBadge = document.getElementById('difficulty-badge');
                difficultyBadge.textContent = gameState.difficulty.toUpperCase();
                difficultyBadge.className = `difficulty-badge difficulty-${gameState.difficulty}`;
                
                if (gameState.targetDescription) {
                    document.getElementById('tooltip-title').textContent = gameState.targetPage;
                    document.getElementById('tooltip-description').textContent = gameState.targetDescription;
                }
            }

            showWinScreen() {
                this.stopTimer();
                gameState.hasWon = true;
                
                createConfetti();
                
                const timeInSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
                
                const mode = gameState.isDailyMode ? 'daily' : 'explore';
                stats.recordGame(true, gameState.totalClicks, timeInSeconds, gameState.path, mode, false);
                
                const modal = document.getElementById('win-modal');
                const finalClicksEl = document.getElementById('final-clicks');
                const finalTimeEl = document.getElementById('final-time');
                const finalPagesEl = document.getElementById('final-pages');
                const winPathEl = document.getElementById('win-path');

                finalClicksEl.textContent = gameState.totalClicks;
                finalTimeEl.textContent = this.timerDisplay.textContent;
                finalPagesEl.textContent = gameState.path.length;

                let rating = '';
                let ratingClass = '';
                
                // NEW: Compare with optimal if available
                if (optimalPathData && optimalPathData.found) {
                    const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                    
                    if (efficiency >= 100) {
                        rating = 'üèÜ PERFECT! Optimal path!';
                        ratingClass = 'rating-perfect';
                    } else if (efficiency >= 80) {
                        rating = 'üåü EXCELLENT! Very close to optimal!';
                        ratingClass = 'rating-excellent';
                    } else if (efficiency >= 60) {
                        rating = 'üëç GOOD! Nice work!';
                        ratingClass = 'rating-good';
                    } else {
                        rating = '‚úÖ COMPLETED! Well done!';
                        ratingClass = 'rating-completed';
                    }
                } else {
                    if (gameState.totalClicks <= 3) {
                        rating = 'üèÜ AMAZING! Perfect score!';
                        ratingClass = 'rating-perfect';
                    } else if (gameState.totalClicks <= 5) {
                        rating = 'üåü EXCELLENT! Great job!';
                        ratingClass = 'rating-excellent';
                    } else if (gameState.totalClicks <= 10) {
                        rating = 'üëç GOOD! Well done!';
                        ratingClass = 'rating-good';
                    } else {
                        rating = '‚úÖ COMPLETED! Nice work!';
                        ratingClass = 'rating-completed';
                    }
                }

                let pathHtml = `<div class="performance-rating ${ratingClass}">${rating}</div>`;
                
                if (stats.bestClicks === gameState.totalClicks && stats.totalWins > 1) {
                    pathHtml += '<div style="text-align: center; background: #fff3cd; padding: 10px; border-radius: 8px; margin-bottom: 15px; color: #856404;"><strong>üéâ New Personal Best!</strong></div>';
                }
                
                // NEW: Show comparison if we have optimal path
                if (optimalPathData && optimalPathData.found && optimalPathData.length !== gameState.totalClicks) {
                    const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                    pathHtml += `
                        <div class="path-comparison">
                            <div class="path-comparison-header">
                                <h3>üìä Path Comparison</h3>
                                <div class="efficiency-badge">${efficiency}% Efficient</div>
                            </div>
                        </div>
                    `;
                }
                
                pathHtml += '<h3>üó∫Ô∏è Your Journey:</h3>';
                gameState.path.forEach((pathItem, index) => {
                    const backtrackClass = pathItem.isBacktrack ? ' backtrack' : '';
                    const pageName = typeof pathItem === 'string' ? pathItem : pathItem.page;
                    pathHtml += `<div class="path-item${backtrackClass}">
                        <div class="path-item-number">${index + 1}</div>
                        <div>${pageName}</div>
                    </div>`;
                });
                
                // NEW: Show optimal path if different
                if (optimalPathData && optimalPathData.found && optimalPathData.length !== gameState.totalClicks) {
                    pathHtml += `<h3 style="margin-top: 25px;">‚ú® Optimal Path (${optimalPathData.length} clicks):</h3>`;
                    optimalPathData.path.forEach((page, index) => {
                        pathHtml += `<div class="path-item optimal">
                            <div class="path-item-number">${index + 1}</div>
                            <div>${page}</div>
                        </div>`;
                    });
                }
                
                winPathEl.innerHTML = pathHtml;

                modal.classList.add('active');
            }

            showError(message) {
                this.gameArea.innerHTML = `<div class="error">${message}</div>`;
            }
        }

        // ======================
        // VISUAL EFFECTS
        // ======================
        
        function createConfetti() {
            const colors = ['#0645ad', '#7c3aed', '#f59e0b', '#10b981', '#ef4444', '#ec4899'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.3 + 's';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        function addClickFeedback(element) {
            element.classList.add('click-feedback');
            setTimeout(() => element.classList.remove('click-feedback'), 200);
        }

        // Create ripple effect at touch point
        function createRipple(element, x, y) {
            const ripple = document.createElement('span');
            ripple.className = 'ripple';

            const rect = element.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const xPos = x - rect.left - size / 2;
            const yPos = y - rect.top - size / 2;

            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = xPos + 'px';
            ripple.style.top = yPos + 'px';

            element.style.position = 'relative';
            element.style.overflow = 'hidden';
            element.appendChild(ripple);

            setTimeout(() => ripple.remove(), 600);
        }

        // ======================
        // SHARE FUNCTIONALITY
        // ======================
        function generateShareText() {
            const emoji = gameState.totalClicks <= 3 ? 'üèÜ' : gameState.totalClicks <= 5 ? 'üåü' : gameState.totalClicks <= 10 ? 'üëç' : '‚úÖ';
            
            let modeText = '';
            if (gameState.isDailyMode) {
                const date = new Date(gameState.dailyDate);
                const options = { month: 'short', day: 'numeric', year: 'numeric' };
                modeText = `üìÖ Daily Challenge - ${date.toLocaleDateString('en-US', options)}\n`;
            } else {
                modeText = `üß≠ Explore Mode\n`;
            }
            
            // NEW: Include minimum clicks if available
            let efficiencyText = '';
            if (optimalPathData && optimalPathData.found) {
                const efficiency = Math.round((optimalPathData.length / gameState.totalClicks) * 100);
                efficiencyText = `‚ö° Efficiency: ${efficiency}% (${optimalPathData.length} min)\n`;
            }
            
            const pathVisual = gameState.path.map((page, i) => {
                if (i === 0) return `üéØ ${page}`;
                if (i === gameState.path.length - 1) return `‚úÖ ${page}`;
                return `  ‚Üí ${page}`;
            }).join('\n');
            
            return `${emoji} WikiPath Challenge ${emoji}
${modeText}
${gameState.startPage} ‚ûú ${gameState.targetPage}

üìä Results:
‚úì Clicks: ${gameState.totalClicks}
${efficiencyText}‚è±Ô∏è Time: ${document.getElementById('timer').textContent}
üìÑ Pages: ${gameState.path.length}

üó∫Ô∏è My Path:
${pathVisual}

Play at: ${window.location.origin}${window.location.pathname}`;
        }

        function shareResult() {
            const shareText = generateShareText();
            
            if (navigator.share) {
                navigator.share({
                    title: 'WikiPath Challenge',
                    text: shareText
                }).catch(err => {
                    console.log('Error sharing:', err);
                    copyResultToClipboard();
                });
            } else {
                copyResultToClipboard();
            }
        }

        function copyResultToClipboard() {
            const shareText = generateShareText();
            
            navigator.clipboard.writeText(shareText).then(() => {
                showNotification('Copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                const textArea = document.createElement('textarea');
                textArea.value = shareText;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showNotification('Copied to clipboard!');
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                }
                document.body.removeChild(textArea);
            });
        }

        function showNotification(message = '‚úì Copied to clipboard!') {
            const notification = document.getElementById('share-notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // ======================
        // BROWSER BACK BUTTON HANDLER
        // ======================
        window.addEventListener('popstate', function(event) {
            console.log('üîô Popstate event fired!', event.state);
            const urlParams = getUrlParams();
            console.log('URL params:', urlParams);

            if (urlParams.start && urlParams.target) {
                if (urlParams.daily) {
                    gameState.isDailyMode = true;
                    gameState.dailyDate = urlParams.daily;

                    if (urlParams.daily !== getTodayDateString()) {
                        location.reload();
                        return;
                    }
                } else {
                    gameState.isDailyMode = false;
                }

                const previousPage = gameState.currentPage;
                const targetPage = urlParams.current || urlParams.start;

                // Check if we're in an active game (path exists and not empty)
                const isActiveGame = gameState.path && gameState.path.length > 0;

                gameState.startPage = urlParams.start;
                gameState.targetPage = urlParams.target;
                gameState.currentPage = targetPage;
                gameState.clickCount = urlParams.clicks;
                gameState.totalClicks = Math.max(gameState.totalClicks, urlParams.totalClicks);
                gameState.visitedPages = new Set(urlParams.visited);

                // Only restore path if we're not in an active game (e.g., page refresh)
                if (!isActiveGame) {
                    gameState.path = urlParams.path.length > 0 ? urlParams.path : [{ page: urlParams.start, isBacktrack: false }];
                }

                // Add the backtrack to the path if we're in an active game and moved to different page
                if (isActiveGame && previousPage && previousPage !== gameState.currentPage) {
                    gameState.path.push({ page: gameState.currentPage, isBacktrack: true });
                    gameState.clickCount++;

                    // Update the URL state to include the backtrack
                    const params = new URLSearchParams();
                    params.set('start', gameState.startPage);
                    params.set('target', gameState.targetPage);
                    params.set('current', gameState.currentPage);
                    params.set('clicks', gameState.clickCount);
                    params.set('totalClicks', gameState.totalClicks);
                    params.set('visited', Array.from(gameState.visitedPages).join(','));
                    params.set('path', JSON.stringify(gameState.path));
                    params.set('startTime', gameState.startTime);

                    if (gameState.isDailyMode) {
                        params.set('daily', gameState.dailyDate);
                    }

                    const newUrl = `${window.location.pathname}?${params.toString()}`;
                    const state = {
                        start: gameState.startPage,
                        target: gameState.targetPage,
                        current: gameState.currentPage,
                        clicks: gameState.clickCount,
                        totalClicks: gameState.totalClicks,
                        visited: Array.from(gameState.visitedPages),
                        path: gameState.path,
                        startTime: gameState.startTime,
                        isDailyMode: gameState.isDailyMode,
                        dailyDate: gameState.dailyDate
                    };

                    window.history.replaceState(state, '', newUrl);
                }

                updateModeUI();
                game.updateDisplay();
                game.updatePathDisplay();
                game.loadPage(gameState.currentPage);
            }
        });

        // ======================
        // STATISTICS MODAL
        // ======================
        function openStats() {
            updateStatsDisplay();
            const modal = document.getElementById('stats-modal');
            modal.classList.add('active');
        }

        function closeStats() {
            const modal = document.getElementById('stats-modal');
            modal.classList.remove('active');
        }

        function updateStatsDisplay() {
            document.getElementById('stat-streak').textContent = stats.dailyStreak;
            document.getElementById('stat-games').textContent = stats.totalGamesPlayed;
            document.getElementById('stat-wins').textContent = stats.totalWins;
            
            const winRate = stats.totalGamesPlayed > 0 
                ? Math.round((stats.totalWins / stats.totalGamesPlayed) * 100) 
                : 0;
            document.getElementById('stat-winrate').textContent = `${winRate}% win rate`;
            
            document.getElementById('stat-best-clicks').textContent = 
                stats.bestClicks !== null ? stats.bestClicks : '-';
            
            document.getElementById('stat-best-time').textContent = 
                stats.bestTime !== null ? formatTime(stats.bestTime) : '-';
            
            document.getElementById('stat-avg-clicks').textContent = 
                stats.totalWins > 0 ? stats.averageClicks : '-';
            
            document.getElementById('stat-avg-time').textContent = 
                stats.totalWins > 0 ? formatTime(stats.averageTime) : '-';
            
            const recentGamesList = document.getElementById('recent-games-list');
            if (stats.recentGames.length === 0) {
                recentGamesList.innerHTML = '<p style="text-align: center; color: #777; padding: 20px;">No games played yet</p>';
            } else {
                recentGamesList.innerHTML = stats.recentGames.map(game => {
                    const date = new Date(game.date);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                    
                    const resultText = game.gaveUp ? 'Gave Up' : (game.won ? 'Won' : 'Lost');
                    const resultClass = game.gaveUp ? 'gave-up' : '';
                    
                    return `
                        <div class="recent-game-item ${resultClass}">
                            <div class="recent-game-info">
                                <div class="recent-game-result ${resultClass}">${resultText}</div>
                                <div class="recent-game-stats">
                                    <span>üéØ ${game.clicks} clicks</span>
                                    <span>‚è±Ô∏è ${formatTime(game.time)}</span>
                                    <span>${game.mode === 'daily' ? 'üìÖ Daily' : 'üß≠ Explore'}</span>
                                </div>
                            </div>
                            <div class="recent-game-date">${dateStr} ${timeStr}</div>
                        </div>
                    `;
                }).join('');
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ======================
        // FAB MENU TOGGLE
        // ======================
        function toggleFabMenu() {
            const menu = document.getElementById('fab-menu');
            menu.classList.toggle('open');
        }

        function closeFabMenu() {
            const menu = document.getElementById('fab-menu');
            menu.classList.remove('open');
        }

        document.addEventListener('click', (e) => {
            const menu = document.getElementById('fab-menu');
            const menuButton = document.querySelector('.fab-menu-button');
            
            if (menuButton && menuButton.contains(e.target)) {
                return;
            }
            
            if (menu && !menu.contains(e.target)) {
                menu.classList.remove('open');
            }
        });

        // ======================
        // TOC COLLAPSE CONTROLS
        // ======================
        function collapseAllTOC() {
            document.querySelectorAll('.toc-section-header').forEach(header => {
                header.classList.add('collapsed');
            });
            document.querySelectorAll('.toc-subsections').forEach(list => {
                list.classList.add('collapsed');
            });
        }

        function expandAllTOC() {
            document.querySelectorAll('.toc-section-header').forEach(header => {
                header.classList.remove('collapsed');
            });
            document.querySelectorAll('.toc-subsections').forEach(list => {
                list.classList.remove('collapsed');
            });
        }

        // ======================
        // PATH PANEL TOGGLE
        // ======================
        function togglePathPanel() {
            const panel = document.getElementById('path-panel');
            const desktopActions = document.querySelector('.desktop-actions');
            panel.classList.toggle('open');
            if (desktopActions) {
                desktopActions.classList.toggle('panel-open');
                console.log('Desktop actions panel-open class:', desktopActions.classList.contains('panel-open'));
            }
        }

        // ======================
        // GIVE UP FUNCTIONALITY
        // ======================
        let globalGameController = null;

        function retryGame() {
            if (!gameState.startPage || !gameState.targetPage) {
                showNotification('‚ùå No game to retry');
                return;
            }
            
            const confirmed = confirm(`üîÑ Retry this challenge?\n\nStart: ${gameState.startPage}\nTarget: ${gameState.targetPage}\n\nYour progress will be reset.`);
            
            if (!confirmed) {
                return;
            }
            
            // Reload the page with the same start and target
            const normalizedStart = gameState.startPage.replace(/ /g, '_');
            const normalizedTarget = gameState.targetPage.replace(/ /g, '_');
            
            window.location.href = `?start=${encodeURIComponent(normalizedStart)}&target=${encodeURIComponent(normalizedTarget)}`;
        }

        function giveUp() {
            const confirmed = confirm(`Are you sure you want to give up?\n\nThis will show you the target page but won't count as a win.`);
            
            if (!confirmed) {
                return;
            }
            
            if (globalGameController) {
                globalGameController.stopTimer();
            }
            gameState.gaveUp = true;
            
            const timeInSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
            const mode = gameState.isDailyMode ? 'daily' : 'explore';
            stats.recordGame(false, gameState.totalClicks, timeInSeconds, gameState.path, mode, true);
            
            const modal = document.getElementById('win-modal');
            const modalContent = modal.querySelector('.modal-content');
            
            modalContent.innerHTML = `
                <h2>üè≥Ô∏è Challenge Ended</h2>
                <div class="win-stats">
                    <div class="stat-row">
                        <span class="stat-label">You were trying to reach:</span>
                        <span class="stat-value">${gameState.targetPage}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Clicks Used:</span>
                        <span class="stat-value">${gameState.totalClicks}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Time Spent:</span>
                        <span class="stat-value">${document.getElementById('timer').textContent}</span>
                    </div>
                </div>
                <div class="win-path">
                    <h3>üó∫Ô∏è Your Path So Far:</h3>
                    ${gameState.path.map((pathItem, index) => {
                        const backtrackClass = (typeof pathItem === 'object' && pathItem.isBacktrack) ? ' backtrack' : '';
                        const pageName = typeof pathItem === 'string' ? pathItem : pathItem.page;
                        return `
                        <div class="path-item${backtrackClass}">
                            <div class="path-item-number">${index + 1}</div>
                            <div>${pageName}</div>
                        </div>
                    `}).join('')}
                    <div style="text-align: center; margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; color: #856404;">
                        <strong>üí° Tip:</strong> Try exploring links related to broader categories or finding connections through related topics!
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn secondary" onclick="retryGame()">üîÑ Try Again</button>
                    <button class="modal-btn secondary" onclick="startNewGame()">üéÆ New Challenge</button>
                </div>
            `;
            
            modal.classList.add('active');
        }

        // ======================
        // SEARCH FUNCTIONALITY (Ctrl+F)
        // ======================
        let searchOverlay = null;
        let searchInput = null;
        let searchResults = null;

        function initializeSearch() {
            searchOverlay = document.getElementById('search-overlay');
            searchInput = document.getElementById('search-input');
            searchResults = document.getElementById('search-results');
            
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                
                if (((e.ctrlKey || e.metaKey) && e.key === 'n') || (e.key === 'n' && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey)) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        return;
                    }
                    
                    e.preventDefault();
                    
                    if (!gameState.isDailyMode) {
                        handleNewGame();
                    } else {
                        showNotification('New Game shortcut is only available in Explore mode');
                    }
                }
                
                if (e.key === 'Escape' && searchOverlay.classList.contains('active')) {
                    closeSearch();
                }
                
                // 'H' for hint
                if (e.key === 'h' || e.key === 'H') {
                    console.log('H key pressed!');
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        console.log('Ignored - typing in input field');
                        return;
                    }
                    
                    const hintBtn = document.getElementById('hint-btn');
                    console.log('Hint button:', hintBtn);
                    console.log('Button disabled?', hintBtn?.disabled);
                    console.log('Game state:', {
                        currentPage: gameState.currentPage,
                        targetPage: gameState.targetPage,
                        hasWon: gameState.hasWon
                    });
                    
                    // Check if game is active by checking if we have current and target pages and haven't won yet
                    if (hintBtn && !hintBtn.disabled && gameState.currentPage && gameState.targetPage && !gameState.hasWon) {
                        console.log('Triggering hint!');
                        e.preventDefault();
                        hintBtn.click();
                    } else {
                        console.log('Hint conditions not met');
                    }
                }
                
                // 'R' for retry
                if (e.key === 'r' || e.key === 'R') {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                        return;
                    }
                    
                    const retryBtn = document.getElementById('retry-btn');
                    if (retryBtn && !retryBtn.disabled && gameState.startPage && gameState.targetPage) {
                        e.preventDefault();
                        retryBtn.click();
                    }
                }
            });
            
            searchOverlay.addEventListener('click', (e) => {
                if (e.target === searchOverlay) {
                    closeSearch();
                }
            });
            
            searchInput.addEventListener('input', performSearch);
        }

        function openSearch() {
            searchOverlay.classList.add('active');
            searchInput.value = '';
            searchResults.innerHTML = '';
            searchInput.focus();
        }

        function closeSearch() {
            searchOverlay.classList.remove('active');
        }

        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            searchResults.innerHTML = '';
            
            if (query.length < 2) {
                return;
            }
            
            const gameArea = document.getElementById('game-area');
            const allLinks = gameArea.querySelectorAll('a');
            const allText = gameArea.querySelectorAll('p, li, h1, h2, h3, h4');
            
            let results = [];
            
            allLinks.forEach(link => {
                const text = link.textContent.toLowerCase();
                if (text.includes(query)) {
                    results.push({
                        type: 'link',
                        text: link.textContent,
                        element: link,
                        context: link.parentElement.textContent.substring(0, 150)
                    });
                }
            });
            
            allText.forEach(el => {
                const text = el.textContent.toLowerCase();
                if (text.includes(query) && !results.some(r => r.element === el)) {
                    const index = text.indexOf(query);
                    const start = Math.max(0, index - 50);
                    const end = Math.min(text.length, index + 100);
                    results.push({
                        type: 'text',
                        text: el.textContent.substring(start, end),
                        element: el
                    });
                }
            });
            
            results = results.slice(0, 20);
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div style="text-align: center; padding: 20px; color: #777;">No results found</div>';
                return;
            }
            
            results.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'search-result-item';
                
                const highlightedText = result.text.replace(
                    new RegExp(`(${query})`, 'gi'),
                    '<strong>$1</strong>'
                );
                
                resultDiv.innerHTML = `
                    <div style="font-size: 0.9em; color: #667eea; margin-bottom: 5px;">
                        ${result.type === 'link' ? 'üîó Link' : 'üìÑ Text'}
                    </div>
                    <div>${highlightedText}...</div>
                `;
                
                resultDiv.addEventListener('click', () => {
                    result.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    closeSearch();
                    
                    result.element.style.backgroundColor = '#ffeb3b';
                    setTimeout(() => {
                        result.element.style.backgroundColor = '';
                    }, 2000);
                });
                
                searchResults.appendChild(resultDiv);
            });
        }

        // ======================
        // INITIALIZE GAME
        // ======================
        const game = new GameController();
        globalGameController = game;
        game.initialize();
        initializeSearch();

        // Add subtle hint animation to action sidebar on first visit
        const hasSeenSidebar = localStorage.getItem('wikipath_sidebar_seen');
        if (!hasSeenSidebar) {
            const desktopActions = document.querySelector('.desktop-actions');
            if (desktopActions) {
                desktopActions.classList.add('first-load');
                // Remove animation class after it completes
                setTimeout(() => {
                    desktopActions.classList.remove('first-load');
                    localStorage.setItem('wikipath_sidebar_seen', 'true');
                }, 6000); // 3 pulses √ó 2 seconds
            }
        }

        // Add responsive resize listener for collapsible sections
        let resizeTimeout;
        window.addEventListener('resize', () => {
            // Debounce resize events
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (globalGameController) {
                    globalGameController.updateCollapsibleSectionsForResize();
                }
            }, 150);
        });

        // Mobile header scroll behavior
        if (window.innerWidth <= 768) {
            const headerTop = document.querySelector('.header-top');
            const contentArea = document.querySelector('.content-area');
            let lastScrollTop = 0;

            if (contentArea && headerTop) {
                contentArea.addEventListener('scroll', () => {
                    const scrollTop = contentArea.scrollTop;

                    // Add 'scrolled' class when scrolled down more than 50px
                    if (scrollTop > 50) {
                        headerTop.classList.add('scrolled');
                    } else {
                        headerTop.classList.remove('scrolled');
                    }

                    lastScrollTop = scrollTop;
                }, { passive: true });
            }
        }

        function startNewGame() {
            clearUrl();
            location.reload();
        }

        function retryGame() {
            if (!gameState.startPage || !gameState.targetPage) {
                return;
            }
            
            const modal = document.getElementById('win-modal');
            modal.classList.remove('active');
            
            const start = gameState.startPage;
            const target = gameState.targetPage;
            const difficulty = gameState.difficulty;
            
            gameState.currentPage = start;
            gameState.clickCount = 0;
            gameState.totalClicks = 0;
            gameState.visitedPages = new Set([start]);
            gameState.path = [{ page: start, isBacktrack: false }];
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.hasWon = false;
            gameState.gaveUp = false;
            gameState.difficulty = difficulty;
            
            updateUrl(
                start,
                target,
                start,
                0,
                0,
                [start],
                [start],
                gameState.startTime
            );
            
            location.reload();
        }
        
        // ======================
        // DEBUG MODE FUNCTIONS
        // ======================
        
        function toggleDebugMode() {
            const toggle = document.getElementById('debug-toggle');
            const panel = document.getElementById('debug-panel');
            const isActive = toggle.classList.toggle('active');
            panel.classList.toggle('active');
            
            localStorage.setItem('wikipath_debug_mode', isActive);
        }
        
        async function startDebugGame() {
            const startPage = document.getElementById('debug-start-page').value.trim();
            const targetPage = document.getElementById('debug-target-page').value.trim();
            const errorEl = document.getElementById('debug-game-error');
            
            errorEl.classList.remove('active');
            
            if (!startPage || !targetPage) {
                errorEl.textContent = '‚ùå Please enter both start and target pages';
                errorEl.classList.add('active');
                return;
            }
            
            if (startPage.toLowerCase() === targetPage.toLowerCase()) {
                errorEl.textContent = '‚ùå Start and target must be different';
                errorEl.classList.add('active');
                return;
            }
            
            const startValid = await validateWikipediaPage(startPage);
            const targetValid = await validateWikipediaPage(targetPage);
            
            if (!startValid) {
                errorEl.textContent = `‚ùå Start page "${startPage}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            if (!targetValid) {
                errorEl.textContent = `‚ùå Target page "${targetPage}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            const normalizedStart = startPage.replace(/ /g, '_');
            const normalizedTarget = targetPage.replace(/ /g, '_');
            
            gameState.isDailyMode = false;
            updateModeUI();
            
            window.location.href = `?start=${encodeURIComponent(normalizedStart)}&target=${encodeURIComponent(normalizedTarget)}`;
        }
        
        async function loadDebugPreview() {
            const pageName = document.getElementById('debug-preview-page').value.trim();
            const errorEl = document.getElementById('debug-preview-error');
            
            errorEl.classList.remove('active');
            
            if (!pageName) {
                errorEl.textContent = '‚ùå Please enter a page name';
                errorEl.classList.add('active');
                return;
            }
            
            const valid = await validateWikipediaPage(pageName);
            
            if (!valid) {
                errorEl.textContent = `‚ùå Page "${pageName}" not found`;
                errorEl.classList.add('active');
                return;
            }
            
            const normalizedPage = pageName.replace(/ /g, '_');
            gameState.currentPage = normalizedPage;
            
            try {
                const pageData = await fetchWikipediaPage(normalizedPage);
                globalGameController.renderPage(pageData);
                globalGameController.buildTableOfContents(pageData.sections || []);
                
                document.getElementById('game-area').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                errorEl.textContent = `‚ùå Error loading page: ${error.message}`;
                errorEl.classList.add('active');
            }
        }
        
        async function validateWikipediaPage(pageName) {
            try {
                const endpoint = 'https://en.wikipedia.org/w/api.php';
                const params = new URLSearchParams({
                    action: 'query',
                    titles: pageName,
                    format: 'json',
                    origin: '*'
                });
                
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                
                return pageId !== '-1';
            } catch (error) {
                console.error('Page validation error:', error);
                return false;
            }
        }
        
        function fillRandomPages() {
            const randomStart = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            let randomTarget;
            do {
                randomTarget = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            } while (randomTarget === randomStart);
            
            document.getElementById('debug-start-page').value = randomStart;
            document.getElementById('debug-target-page').value = randomTarget;
        }
        
        function fillRandomPreview() {
            const randomPage = ALL_PAGES[Math.floor(Math.random() * ALL_PAGES.length)];
            document.getElementById('debug-preview-page').value = randomPage;
        }
        
        // ======================
        // WIKIPEDIA AUTOCOMPLETE
        // ======================
        
        let autocompleteTimeout = null;
        
        function setupAutocomplete(inputId, dropdownId) {
            const input = document.getElementById(inputId);
            const dropdown = document.getElementById(dropdownId);
            let selectedIndex = -1;
            
            input.addEventListener('input', async (e) => {
                const query = e.target.value.trim();
                
                clearTimeout(autocompleteTimeout);
                
                if (query.length < 2) {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                    return;
                }
                
                autocompleteTimeout = setTimeout(async () => {
                    const suggestions = await getWikipediaSuggestions(query);
                    
                    if (suggestions.length > 0) {
                        dropdown.innerHTML = '';
                        selectedIndex = -1;
                        
                        suggestions.forEach((suggestion, index) => {
                            const item = document.createElement('div');
                            item.className = 'debug-autocomplete-item';
                            item.textContent = suggestion;
                            
                            item.addEventListener('click', () => {
                                input.value = suggestion;
                                dropdown.classList.remove('active');
                                dropdown.innerHTML = '';
                            });
                            
                            dropdown.appendChild(item);
                        });
                        
                        dropdown.classList.add('active');
                    } else {
                        dropdown.classList.remove('active');
                        dropdown.innerHTML = '';
                    }
                }, 300);
            });
            
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.debug-autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items, selectedIndex);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items, selectedIndex);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                } else if (e.key === 'Escape') {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });
            
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });
        }
        
        function updateSelection(items, index) {
            items.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        async function getWikipediaSuggestions(query) {
            try {
                const endpoint = 'https://en.wikipedia.org/w/api.php';
                const params = new URLSearchParams({
                    action: 'opensearch',
                    search: query,
                    limit: 8,
                    namespace: 0,
                    format: 'json',
                    origin: '*'
                });
                
                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();
                
                return data[1] || [];
            } catch (error) {
                console.error('Autocomplete error:', error);
                return [];
            }
        }

    </script>
</body>
</html>
